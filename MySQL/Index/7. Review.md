-----
### 결론 : 인덱스를 생성해야 하는 경우와 그렇지 않은 경우
-----
1. 인덱스를 잘 사용하면 쿼리의 성능이 급격히 향상하지만, 그렇지 않은 경우에는 오히려 쿼리의 성능이 떨어지며 전반적인 MySQL 성능이 나빠질 수 있음
2. '테이블의 구성이 어떻게 되었는지, 어떠한 조회를 많이 사용하는지' 등에 따라 인덱스를 생성
   - 💡 인덱스는 열 단위에 생성
     + 하나의 열에만 생성되는 것이 아니라 두 개 이상의 열을 조합해서 인덱스를 생성할 수 있었음

   - 💡 WHERE 절에 사용되는 열에 인덱스를 만들어야 함
     + 테이블 조회 시 인덱스를 사용하는 경우는 WHERE 절의 조건에 해당 열이 나오는 경우에만 주로 사용
     + 예) sqlDB의 usertbl
```sql
SELECT name, birthYear, addr FROM usertbl WHERE userID = 'KKH'
```
  - 위에서 name, birthYear, addr열에 인덱스를 생성해봤자 전혀 사용할 일이 없음
  - WHERE 절에 있는 userID열에만 인덱스를 생성할 필요가 있음

    - 💡 WHERE 절에 자주 사용되더라도 자주 사용해야 가치가 있음
      + 만약, 위 쿼리에서 userID열에 인덱스를 생성해서 효율이 아주 좋다고 하더라도, SELECT 절에 아주 가끔 사용하고, 이 테이블에 INSERT 작업만 주로 일어나면?
      + 특히, userID열이 클러스터형 인덱스라면, 데이터를 입력하는 성능이 무척 나빠질 것
      + 즉, 클러스터형 인덱스에는 데이터 입력 과정이 매번 일어나서 페이지 분할 작업이 계속 발생
      + 또한, 보조 인덱스도 데이터 페이지 분할은 클러스터형 인덱스에 비해 덜 일어나지만 인덱스 페이지의 페이지 분할은 종종 발생할 것
      + 💡 인덱스는 테이블을 정의하는 시점에 어디에 생성할 것인지 잘 설계한 후 지정하는 것이 가장 바람직

    - 💡 데이터의 중복도가 높은 열은 인덱스를 만들어도 별 효과가 없음
      + 거의 같은 데이터가 있는 열은 보조 인덱스를 만들어도 MySQL이 사용하지 않거나, 사용하더라도 크게 성능 향상 효과가 없는 경우 존재
      + 오히려, 인덱스에 대한 관리 비용 때문에 인덱스가 없는 편이 나을 수 있음
      + 따라서, 데이터의 중복도가 높은 열에는 인덱스를 만들 것인지 신중하게 판단

    - 💡 외래 키를 지정한 열에는 자동으로 외래 키 인덱스가 새성
      + 외래 키 제약 조건 열에는 자동으로 인덱스 생성
      + 그리고, 쿼리문에서 외래 키 인덱스가 필요할 경우 MySQL이 알아서 외래 키 인덱스 사용

    - 💡 JOIN에 자주 사용되는 열에는 인덱스를 생성해주는 것이 좋음
    - 💡 INSERT / UPDATE / DELETE가 얼마나 자주 일어나는지 고려
      + 인덱스를 많이 만들어도 성능에 문제가 되지 않는 테이블은 INSERT 작업이 거의 발생되지 않는 테이블
      + 즉, OLAP 데이터베이스의 경우 인덱스를 만들어도 문제는 없으나, OLTP 데이터베이스는 데이터 입력 및 갱신이 자주 일어나게 되므로 필요 없는 열에 인덱스를 생성하면 성능에 나쁜 영향을 미칠 수 있음
      + 💡 따라서, 인덱스를 만들어서 SELECT의 성능을 높일 것인지, 만들지 않아서 INSERT / UPDATE / DELETE 시에 영향을 최소화할 것인지 잘 결정

    - 💡 클러스터형 인덱스는 테이블 당 하나만 생성 가능
      + 💡 클러스터형 인덱스를 생성할 열은 범위(BETWEEN, <, > 등의 조건)로 사용하거나 집계 함수를 사용하는 경우에 아주 적절
      + 💡 클러스터형 인덱스는 데이터 페이지를 읽는 수가 최소화 되어서 성능이 아주 우수하므로 조건에서 가장 많이 사용되는 열에 생성하는 것이 바람직
      + 💡 또한, ORDER BY 절에 자주 나오는 열도 클러스터형 인덱스가 유리
      + 💡 클러스터형 인덱스의 데이터 페이지(=리프 페이지)는 이미 정렬되어 있기 때문임

    - 클러스터형 인덱스가 아예 없는 것이 좋은 경우도 있음
      + 회원 테이블의 정의
```sql
CREATE TABLE usertbl (
    userID CHAR(8) NOT NULL PRIMARY KEY,
    name VARCHAR(10) NOT NULL,
    birthYear INT NOT NULL
);
```
  - 클러스터형 인덱스로 구성되어 있으므로 데이터가 입력되는 즉시 정렬이 계속 수행되고, 페이지 분할이 끊임없이 일어날 수 있으므로, 시스템 성능에 문제 발생 가능 존재
  - 이런 경우 차라리 클러스터형 인덱스가 없는 편이 나을 수 있으며, Primary Key 대신 Unique로 지정하는 편이 나음
```sql
CREATE TABLE usertbl (
    userID CHAR(8) NULL UNIQUE,
    name VARCHAR(10) NOT NULL,
    birthYear INT NOT NULL
);
```
  - 주의할 점은 UNIQUE 키에 NOT NULL을 함께 지정하면 클러스터형 인덱스가 생성되므로 NULL로 지정

     - 사용하지 않는 인덱스는 제거
       + 운영되는 응용 프로그램의 쿼리들을 분석해 WHERE 조건에서 사용하지 않는 열의 인덱스는 제거할 필요 있음
       + 그러면, 공간 확보 뿐만 아니라 데이터 입력 시 발생되는 부하도 많이 줄일 수 있음

    
