-----
### 인덱스의 단점과 주의사항
-----
1. 인덱스는 공짜가 아님 (인덱스의 단점)
   - 인덱스의 단점은 크게 두 가지 비용으로 설명할 수 있음
   - 저장 공간 (Storage)
      + 인덱스는 원본 테이블과는 별개로, B-Tree 구조를 가진 물리적인 파일로 디스크에 저장
      + 즉, 인덱스를 생성하면 그만큼의 추가 저장 공간이 필요
      + 인덱스는 어떻게 구성하는지에 따라 다르지만, 일반적으로 원본 테이블 크기의 약 10% 내외의 공간을 추가로 차지한다고 알려져 있음
        * 만약 100GB에 달하는 거대한 items 테이블이 있고, 여기에 5개의 인덱스를 추가로 생성한다면?
        * 인덱스만으로 약 50GB라는 무시할 수 없는 추가 디스크 공간이 필요하게 됨
      + 인덱스를 무분별하게 생성하면 디스크 사용량이 계속해서 늘어나는 것을 보게 될 것

   - 쓰기 성능 (INSERT, UPDATE, DELETE) : 이것이 인덱스의 가장 치명적인 단점이자, 반드시 이해해야 할 핵심 트레이드오프
     + 인덱스는 SELECT의 속도를 높이는 대가로, INSERT, UPDATE, DELETE의 속도를 희생시킴
     + 데이터에 변경이 일어날 때마다, 데이터베이스는 원본 테이블뿐만 아니라 이와 관련된 모든 인덱스를 함께 수정해야 하기 때문임
     + INSERT : 새로운 상품이 등록되면(INSERT), items 테이블에 행이 추가되며, 동시에, 이 테이블에 생성된 모든 인덱스(예) PRIMARY , seller_id , idx_items_category_price)의 B-Tree에도 새로운 데이터에 대한 키 값과 주소가 추가되어야 함
       * 이 과정에서 B-Tree의 정렬 순서를 유지하고 균형을 맞추기 위한 추가적인 연산이 발생
       * 인덱스가 5개라면, 테이블 삽입 1번에 인덱스 삽입 5번의 작업이 추가되는 셈
     + DELETE : 상품이 삭제되면(DELETE), 테이블에서 행이 사라짐 (동시에 모든 인덱스에서도 해당 상품에 대한키 값이 삭제되어야 함)
     + UPDATE : 상품 정보가 수정될 때가 가장 복잡
       * 만약 인덱스가 없는 stock_quantity 컬럼의 값이 변경된다면, 인덱스는 수정할 필요가 없으므로 비교적 빠름
       * 하지만 인덱스가 있는 price 컬럼의 값이 변경된다면, 데이터베이스는 기존 price 값으로 된 인덱스 항목을 '삭제'하고, 새로운 price 값으로 인덱스 항목을 '추가'하는 것과 유사한 작업을 수행
       * 왜냐하면 인덱스는 변경된 값에 맞추어 새로운 정렬 상태를 유지해야 하기 때문임
       * 이는 INSERT와 DELETE가 동시에 발생하는 것과 같아 부하가 큼

2. 실무 가이드 : 균형의 미학
   - 워크로드를 분석할 것 : 읽기 vs 쓰기
     + 읽기 중심(Read-heavy) 서비스 : 데이터 분석 시스템, 블로그, 뉴스 사이트처럼 데이터 변경보다는 조회가 훨씬 더 빈번한 서비스라면, 다양한 조회 성능을 높이기 위해 인덱스를 비교적 자유롭게 생성해도 좋음
     + 쓰기 중심(Write-heavy) 서비스 : 실시간으로 데이터를 기록하는 로깅 시스템, 주식 거래 시스템, 채팅 서비스처럼 INSERT나 UPDATE가 매우 빈번한 서비스라면, 인덱스 생성에 매우 신중하고 보수적이어야 함
       * 모든 인덱스는 쓰기 작업에 오버헤드를 추가하기 때문이며, 꼭 필요한 최소한의 인덱스만 유지해야 함

   - 혹시나 해서 인덱스를 만들지 말 것
     + 사용하지 않는 인덱스는 저장 공간만 차지하고 쓰기 성능만 저하시키는 암적인 존재로, 명확한 목적 없이, '나중에 쓸 것 같다'라는 이유로 인덱스를 미리 만드는 것은 좋지 않음
     + 느린 쿼리가 발견되었을 때, 그 쿼리를 개선하기 위한 목적으로 생성해야 함

   - 사용하지 않는 인덱스는 주기적으로 정리할 것
     + 대부분의 데이터베이스는 특정 인덱스가 얼마나 사용되었는지 모니터링하는 기능을 제공
     + 몇 달, 혹은 1년 이상 아무도 사용하지 않는 인덱스가 있다면, 과감하게 삭제하여 시스템 자원을 확보하고 쓰기 성능을 높여야 함

3. 인덱스는 SELECT 성능을 위한 최고의 무기이지만, 저장 공간과 쓰기 성능이라는 비용을 요구하는 양날의 검과 같음
   - 데이터베이스의 더 근본적인 역할은 데이터를 '안전하게 지키는' 것
   - 만약 상품 가격에 음수(-)가 들어가거나, 있지도 않은 판매자 ID로 상품이 등록되는 등 말도 안 되는 '쓰레기 데이터'가 시스템에 저장된다면 이는 분석 결과를 왜곡하고, 심각한 시스템 오류를 야기할 수 있음

4. 💡 인덱스 컬럼은 가공하면 안 됨
   - 💡 WHERE 절에서 인덱스가 적용된 컬럼을 함수로 감싸거나 계산을 하는 등 가공하게 되면 인덱스가 적용되지 않음 (이는 실무에서 정말 자주 하는 실수이므로 반드시 기억해야 함)
   - 예를 들어 WHERE 절에서 인덱스가 적용된 컬럼에 SUBSTRING() 같은 함수를 사용하거나 연산을 하면 인덱스가 작동하지 않아 테이블 전체를 스캔하게 되므로 성능이 크게 저하하
   - 문제 : WHERE SUBSTRING(item_name, 1, 5) = '게이밍' 처럼 인덱스 컬럼(item_name)을 가공하면, 데이터베이스는 정렬된 인덱스를 활용하지 못하고 모든 데이터를 일일이 확인
      + WHERE indexed_column * 10 = 100 이런 경우도 마찬가지로 인덱스를 사용하지 못함
   - 💡 원인 : 인덱스는 가공되지 않은 원본 값을 기준으로 만들어지기 때문임
   - 💡 해결책 : 컬럼 자체를 가공하는 대신, LIKE 연산자를 사용하여 WHERE item_name LIKE '게이밍%'와 같이 조건을 변경해야 인덱스를 효율적으로 사용할 수 있음
   - 결론 : SQL 성능을 높이려면 인덱스 컬럼은 절대 가공하지 말고 원본 상태 그대로 사용해야 함
