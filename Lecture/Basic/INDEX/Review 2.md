-----
### 정리
-----
1. 옵티마이저와 인덱스 선택
   - 데이터베이스 옵티마이저는 쿼리 실행 시, 인덱스 사용과 테이블 전체 스캔(Full Table Scan) 중 더 효율적인 방법을 선택
   - 인덱스를 사용하는 것이 오히려 비용이 크다고 판단되면(손익분기점 초과), 인덱스가 있어도 사용하지 않음
   - 일반적으로 전체 데이터의 20~25% 이상을 조회하는 경우, 인덱스를 통한 랜덤 I/O보다 테이블 전체를 순차적으로 읽는 순차 I/O가 더 빠르다고 판단
   - 데이터 양이 매우 적을 때도 옵티마이저는 풀 테이블 스캔을 선택할 수 있음

2. 커버링 인덱스
   - 쿼리에 필요한 모든 컬럼을 포함하는 인덱스를 커버링 인덱스
   - 커버링 인덱스를 사용하면 원본 테이블에 접근하지 않고 인덱스만으로 쿼리를 처리할 수 있어, 랜덤 I/O가 발생하지 않아 성능이 크게 향상
   - 실행 계획(EXPLAIN)의 Extra 컬럼에 Using index 가 표시되면 커버링 인덱스가 사용된 것이
   - SELECT 성능을 크게 높이지만, 인덱스 크기가 커지고 쓰기(INSERT, UPDATE, DELETE) 성능이 저하되는 단점이 존재

3. 복합 인덱스 대원칙
   - 복합 인덱스를 설계하고 사용할 때는 다음 세 가지 대원칙을 지킬 것
      + 인덱스는 순서대로 사용 (왼쪽 접두어 규칙)
      + 등호(=) 조건은 앞으로, 범위 조건(<, >)은 뒤로 설정
      + 정렬(ORDER BY)도 인덱스 순서를 따를 것

4. 복합 인덱스1
   - 두 개 이상의 컬럼을 묶어 하나의 인덱스로 만든 것을 복합 인덱스
   - 컬럼의 순서가 매우 중요하며, 인덱스는 첫 번째 컬럼부터 순서대로 조건에 사용되어야 함(인덱스 왼쪽 접두어규칙)
   - 인덱스가 (A, B) 순서라면 WHERE A =... / WHERE A =... AND B = ... 는 효율적이지만, WHERE B =...는 인덱스를 제대로 활용할 수 없음
   - WHERE 절과 ORDER BY 절이 인덱스 순서와 일치하면, 불필요한 정렬 작업(filesort)을 생략할 수 있어 성능에 매우 유리

5. 복합 인덱스2
   - 복합 인덱스의 첫 번째 컬럼을 건너뛰고 두 번째 이후의 컬럼만 조건으로 사용하면 인덱스를 활용할 수 없어 풀 테이블 스캔이 발생할 수 있음
   - 복합 인덱스의 선행 컬럼에 범위 조건(>, <, BETWEEN 등)이 사용되면, 그 뒤에 오는 컬럼은 인덱스의 정렬 효과를 누릴 수 없어 효율이 떨어짐
   - 범위 조건으로 넓게 가져온 데이터를 필터링하는 방식으로 동작하여, 인덱스의 성능을 절반만 활용

6. 복합 인덱스3
   - 복합 인덱스 설계 시 등호(=) 조건을 사용하는 컬럼을 앞에, 범위 조건을 사용하는 컬럼을 뒤에 두는 것이 일반적인 최적화 전략
   - 범위 검색(>=) 대신 IN 절을 사용하면, 옵티마이저는 이를 여러 개의 동등 비교(=)로 인식하여 복합 인덱스를더 효율적으로 활용할 수 있음

7. 인덱스 설계 가이드라인
   - 인덱스 생성의 가장 중요한 기준은 카디널리티(Cardinality), 즉 값의 고유성 정도
   - 중복도가 낮은(카디널리티가 높은) 컬럼에 생성해야 효과적
   - 인덱스 생성 가이드라인
     + WHERE 절에서 자주 사용되는 컬럼
     + JOIN의 연결고리가 되는 컬럼 (외래 키)
     + ORDER BY 절에서 자주 사용되는 컬럼 (정렬 작업 회피)
 
8. 인덱스의 단점과 주의사항
   - 인덱스는 공짜가 아니며, 단점도 명확히 존재
   - 저장 공간 차지 : 인덱스는 별도의 파일로 저장되어 추가 디스크 공간을 사용
   - 쓰기 성능 저하 : INSERT, UPDATE, DELETE 작업 시 테이블뿐만 아니라 인덱스도 함께 수정해야 하므로 오버헤드가 발생한고, 특히 인덱스 컬럼의 UPDATE는 부하가 큼
   - 읽기 중심 서비스와 쓰기 중심 서비스를 구분하여 필요한 최소한의 인덱스만 생성하고, 사용하지 않는 인덱스는 주기적으로 정리해야 함
