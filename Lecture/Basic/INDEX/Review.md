-----
### 정리
-----
1. 인덱스가 필요한 이유
   - 데이터양이 많아질수록 인덱스 없는 검색은 풀 테이블 스캔(Full Table Scan)으로 인해 매우 느려짐
   - 풀 테이블 스캔은 테이블의 모든 데이터를 처음부터 끝까지 순차적으로 비교하는 방식으로, 데이터 양에 비례하여 성능이 저하
   - 서비스의 빠른 응답 속도는 사용자 경험에 매우 중요하며, 풀 테이블 스캔은 이를 저해하는 주된 원인
   - WHERE 절에 자주 사용되는 컬럼에 인덱스를 생성하는 것이 기본적인 해결책

2. 인덱스 소개
   - 인덱스는 데이터베이스의 검색 성능을 향상시키는, 책의 '찾아보기(색인)'와 같은 자료 구조
   - 특정 컬럼의 값과 해당 데이터의 물리적 위치 주소를 쌍으로 저장
   - 인덱스의 핵심은 데이터가 항상 정렬된 상태로 유지된다는 점이며, 이를 통해 데이터를 매우 빠르게 찾을 수 있음
   - 검색 시 테이블 전체를 스캔하는 대신, 정렬된 인덱스를 먼저 탐색하여 원하는 데이터의 위치로 즉시 이동

3. 트리 자료 구조
   - 인덱스는 주로 트리(Tree) 자료 구조, 특히 B-Tree를 사용하여 구현
   - 이진 탐색 트리와 같이 데이터를 정렬된 상태로 저장하여, 검색 시 O(log n) 의 매우 빠른 시간 복잡도를 가짐
   - 데이터가 100만 건이라도 약 20번의 비교만으로 데이터를 찾을 수 있음
   - 대부분의 데이터베이스는 트리의 한쪽으로 치우치는 문제를 해결한 벨런스 트리(Balanced Tree)를 사용하여 최악의 경우에도 O(log n) 성능을 보장

4. 인덱스 생성, 조회, 삭제
   - CREATE INDEX, SHOW INDEX, DROP INDEX 명령어를 사용하여 인덱스를 생성, 조회, 삭제
   - MySQL에서는 PRIMARY KEY, FOREIGN KEY, UNIQUE 제약조건을 설정하면 해당 컬럼에 인덱스가 자동으로 생성
   - EXPLAIN 명령어를 쿼리 앞에 붙이면 데이터베이스의 실행 계획을 확인할 수 있으며, 이를 통해 인덱스 사용 여부를 반드시 점검해야 함
   - 실행 계획의 type이 ALL이면 풀 테이블 스캔, ref나 range이면 인덱스 사용을 의미

5. 인덱스와 동등 비교
   - 동등 비교(=) 조건에 인덱스가 사용될 때, 실행 계획의 type은 ref로 표시
   - ref 는 인덱스를 통해 조건에 맞는 데이터를 매우 효율적으로 참조했다는 의미
   - 인덱스를 사용하면 탐색해야 할 행(rows)의 수가 극적으로 줄어들어 검색 성능이 크게 향상

6. 인덱스와 범위 검색
   - BETWEEN, >, < 와 같은 범위 검색에 인덱스가 사용될 때, 실행 계획의 type은 range로 표시
   - 데이터베이스는 정렬된 인덱스에서 범위의 시작점을 빠르게 찾고, 범위가 끝날 때까지만 순차적으로 스캔하므로 효율적
   - 인덱스를 사용하면 결과가 인덱스 키 순서로 정렬되어 나올 수 있지만, 정확한 정렬을 위해서는 ORDER BY를 명시해야 함

7. 인덱스와 LIKE 범위 검색
   - LIKE 검색에서 인덱스를 활용하려면 와일드카드(%)가 반드시 검색어의 뒤쪽에 위치해야함 (LIKE '검색어%')
   - 와일드카드가 검색어의 앞에 오면 (LIKE '%검색어') 시작점을 특정할 수 없어 인덱스를 사용하지 못하고 풀 테이블 스캔이 발생
   - 텍스트 중간에 포함된 단어를 검색하기 위해서는 LIKE 대신 전문 검색(Full-Text Search) 기능을 사용해야 함

8. 인덱스와 정렬
   - 정렬(ORDER BY)은 비용이 많이 드는 작업이지만, 인덱스를 활용하면 별도의 정렬 과정(filesort)을 생략하여 성능을 개선할 수 있음
   - WHERE 조건과 ORDER BY 조건이 인덱스와 일치하면, 데이터베이스는 이미 정렬된 인덱스를 순서대로 읽기만 하므로 filesort가 발생하지 않음
   - 내림차순 정렬(DESC) 시에는 인덱스를 거꾸로 읽는 역방향 스캔(Backward index scan)을 통해 filesort를 피할 수 있음
   - 쿼리의 정렬 순서와 일치하는 내림차순 인덱스((컬럼명 DESC))를 생성하면 가장 이상적인 정렬 최적화가 가능
