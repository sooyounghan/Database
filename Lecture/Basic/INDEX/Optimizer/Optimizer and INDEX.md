-----
### 옵티마이저와 인덱스 선택
-----
1. 컬럼에 인덱스를 생성하면, 해당 컬럼을 조건으로 사용하는 모든 WHERE 절의 성능이 향상될 것이라고 기대하기 쉽지만, 하지만 항상 그렇지는 않음
2. 데이터베이스의 옵티마이저(Optimizer)는 쿼리를 실행하기 전에 여러 실행 가능한 방법을 평가하고, 그중 가장 비용이 적게 드는, 즉 가장 효율적이라고 판단되는 방법을 선택
   - 이 과정에서 옵티마이저는 인덱스를 사용하는 것이 오히려 비효율적이라고 판단하면, 인덱스가 존재하더라도 과감히 포기하고 테이블 전체를 스캔(Full Table Scan)하는 방법을 선택할 수 있음
   - 인덱스 사용 예시
<div align="center">
<img src="https://github.com/user-attachments/assets/c0d5ee1a-814e-4105-99de-d18ae4f8e9ab">
</div>

   - 인덱스를 사용하면 검색 대상의 양은 줄어들지만, items 테이블의 여러 위치에 흩어진 데이터에 랜덤하게 접근해야 함
     + 예를 들어, 19, 6, 3, 14, 8번 행 순서로 데이터를 읽어오는 식
   - 풀 테이블 스캔을 사용하면 items 테이블을 순서대로 쭉 읽으면 됨

2. 💡 인덱스 손익분기점
   - 옵티마이저가 인덱스 사용 여부를 결정하는 핵심 기준은 바로 '손익분기점' : 여기서 손익분기점이란, 인덱스를 통해 데이터를 읽는 비용이 테이블 전체를 직접 읽는 비용보다 높아지는 지점을 의미
   - 인덱스를 사용하는 비용 : 인덱스 탐색 비용 + 인덱스에서 찾은 주소로 테이블에 접근하는 비용 (랜덤 I/O)
     + 풀 테이블 스캔 비용 : 테이블 전체를 순차적으로 읽는 비용 (순차 I/O)
     + 일반적으로 전체 데이터의 약 20~25% 이상을 조회해야 하는 쿼리는 인덱스를 통해 테이블의 각 행에 개별적으로 접근하는 것보다, 차라리 테이블 전체를 순차적으로 스캔하는 것이 더 효율적이라고 알려져 있음
     + 즉, 조회하려는 데이터의 양이 손익분기점을 넘어가면 옵티마이저는 인덱스 사용을 포기

3. 왜 랜덤 I/O가 더 느릴까?
   - 랜덤 I/O가 순차 I/O보다 느린 이유는 데이터를 찾는 과정에서 발생하는 시간 때문임
   - 이를 HDD, SSD 디스크를 예로 들어 책 읽기에 비유
      + 순차 I/O (Sequential I/O) → 책을 1페이지부터 순서대로 읽기
         * 데이터가 저장된 위치를 한 번 찾으면, 그 이후로는 순서대로 쭉 읽기만 하면 됨
         * HDD의 경우 디스크의 헤드가 거의 움직이지 않고 연속된 데이터를 읽어오므로 작업이 매우 빠르고 효율적
         * SSD의 경우 하나의 큰 명령으로 처리할 수 있음
      + 랜덤 I/O (Random I/O) → 책의 여러 페이지를 순서 없이 찾아 읽기
         * 5페이지를 읽은 후 200페이지를 읽고, 다시 45페이지를 읽는 것과 같음
         * HDD의 경우 읽어야 할 데이터가 디스크의 여러 곳에 흩어져 있어, 데이터를 읽을 때마다 디스크 헤드가 물리적으로 해당 위치까지 이동해야 함
         * 이렇게 데이터의 위치를 찾는 데 걸리는 시간(탐색 시간, Seek Time)이 추가되기 때문에 순차 I/O에 비해 느림
         * SSD의 경우 찾아야 하는 데이터가 100개라면 100개의 작은 명령을 각각 처리해야 함
         * 작은 명령을 여러 번 처리하는 것은 SSD 컨트롤러에 더 많은 오버헤드(부하)를 줌
         
    - 데이터베이스에서 인덱스를 통해 테이블의 여러 행에 접근하는 것은, 인덱스에 저장된 주소에 따라 디스크의 여러 위치를 오가야 하는 랜덤 I/O를 유발할 수 있음
    - 반면, 테이블 전체를 스캔하는 것은 처음부터 끝까지 데이터를 읽는 순차 I/O에 해당
    - 이 때문에 조회할 데이터가 아주 많을 경우, 여러 번의 랜덤 I/O를 수행하는 것보다 한 번의 순차 I/O가 더 빠를 수 있음

4. 예시 1 : 인덱스를 사용하는 효율적인 범위 검색
   - 먼저, 옵티마이저가 인덱스를 사용하는 것이 효율적이라고 판단하는 경우
   - items 테이블의 price 컬럼에는 idx_items_price 인덱스가 생성되어 있음
```sql
EXPLAIN SELECT *
FROM items
WHERE price BETWEEN 50000 AND 100000;
```
<div align="center">
<img src="https://github.com/user-attachments/assets/36c20590-b191-4b49-95da-37254ee532c3">
</div>

   - (type : range) : 옵티마이저는 idx_items_price 인덱스를 사용해 특정 범위만 스캔
   - (rows : 5) : 조회할 데이터가 5건으로 예상되며, 이는 전체 25건 중 20%에 해당하므로, 손익분기점을 넘지 않음
   - (key : idx_items_price) : 따라서 옵티마이저는 idx_items_price 인덱스를 사용하는 효율적인 실행 계획을 세우게 됨

5. 예시 2 : 인덱스를 포기하는 비효율적인 범위 검색
   - 이번에는 WHERE 절의 범위를 훨씬 더 넓게 잡아보기
   - 기존에 50000 ~ 100000 → 1000 AND 200000 으로 검색 범위를 확 넓힘
```sql
EXPLAIN SELECT *
FROM items
WHERE price BETWEEN 1000 AND 200000;
```
<div align="center">
<img src="https://github.com/user-attachments/assets/fc44f876-dd90-4995-a114-7ed69633dda9">
</div>

   - 실행 계획이 완전히 달라짐
   - (possible_keys : idx_items_price) : 옵티마이저는 idx_items_price 인덱스를 사용할 수 있다는 것을 알고 있었으므로, possible_keys 는 이 쿼리에서 사용할 수 있는 인덱스 후보
   - (key : NULL) : 하지만 최종적으로 인덱스를 사용하지 않기로 결정
   - (type : ALL) : 결국 선택된 방법은 풀 테이블 스캔
   - (filtered : 76.00) : 옵티마이저는 이 쿼리가 전체 데이터(25건)의 약 76%, 즉 19건 정도를 반환할 것이라고 예측하는데, 이 정도면 손익분기점을 훌쩍 넘는 수치

6. 옵티마이저는 19건의 데이터를 찾기 위해 인덱스를 읽고, 다시 테이블에 19번의 개별적인 접근(Random I/O)을 하는 것보다, 그냥 테이블 전체(25건)를 한 번에 쭉 읽는 것(Sequential I/O)이 더 저렴하다고 판단한 것
   - 이처럼 인덱스는 만능이 아님 : WHERE 절에 인덱스가 걸린 컬럼을 사용하더라도, 조회하려는 데이터의 범위가 너무 넓어 손익분기점을 넘어가면 옵티마이저는 인덱스를 사용하지 않을 수 있음
   - 따라서 쿼리 튜닝을 할 때는 EXPLAIN을 통해 옵티마이저가 실제로 인덱스를 사용하고 있는지 반드시 확인하는 습관을 들여야 함

7. 여러 인덱스가 있다면?
   - 선택할 수 있는 인덱스 후보가 여러 개 있다면 옵티마이저는 그 중에서 가장 효율적으로 작동하는 인덱스를 선택
   - 물론 이 경우에도 풀 테이블 스캔이 가장 효율적이라고 판단하면 풀 테이블 스캔을 선택할 수 있음

8. 데이터가 많이 부족하다면?
   - 데이터 자체가 많이 부족하다면 옵티마이저는 풀 테이블 스캔을 선택할 가능성이 있음
   - 테이블에 데이터가 몇 건 없다면, 테이블 전체를 순차적으로 읽는 비용이 인덱스를 탐색하고 테이블에 접근하는 비용보다 훨씬 저렴하기 때문임
   - 1,000페이지짜리 두꺼운 책에서는 색인(인덱스)을 보고 원하는 페이지를 찾아가는 것이 빠름
   - 하지만 단 3페이지짜리 얇은 소책자에서 특정 내용을 찾을 때는, 굳이 색인을 볼 필요 없이 그냥 1페이지부터 빠르게 훑어보는 것이 더 효율적
   - 마찬가지로 옵티마이저도 테이블이 몇 페이지 되지 않을 정도로 작다면, 굳이 인덱스를 사용하는 복잡한 과정을 거치지 않고 테이블 전체를 직접 스캔하는 것이 더 효율적이라고 판단
   - 이는 개발 환경에서 자주 발생하는 오해 중 하나로, 개발 중인 테이블에 소량의 테스트 데이터만 넣고 쿼리를 실행했을 때, EXPLAIN 결과에 (type : ALL)이 표시되어 '인덱스가 왜 작동하지 않지?'라고 생각할 수 있음
   - 하지만 이는 옵티마이저의 지극히 합리적인 판단일 가능성이 높음
   - 프로덕션 환경에서 데이터가 수만, 수백만 건으로 늘어나면, 옵티마이저는 다시 인덱스를 사용하는 효율적인 실행 계획을 선택하게 될 
   - 참고로 테스트 목적으로 인덱스를 강제로 적용하려면 다음과 같이 FORCE INDEX를 사용하면 됨
```sql
SELECT *
FROM my_table
FORCE INDEX (idx_my_index)
WHERE column = 'value';
```
   - 이 방법을 사용하면 쿼리 옵티마이저가 최적의 인덱스를 선택할 수 없기 때문에 실무에서는 권장하지 않음
   - 꼭 필요하다면 주의해서 사용해야 함
