-----
### 트리 자료 구조
-----
1. 인덱스가 어떤 방식으로 데이터를 빠르게 검색하는지 이해하려면 먼저 트리 자료 구조를 알아야 함
<div align="center">
<img src="https://github.com/user-attachments/assets/0b30d137-caa0-4f62-a61d-a87b5c6a271a">
</div>

   - 트리는 부모 노드와 자식 노드로 구성
   - 여기서는 각 원이 노드이며, 노드 안에는 데이터와 다음 노드들의 위치가 보관
   - 가장 높은 조상을 루트(root)라 한함
   - 자식이 2개까지 올 수 있는 트리를 이진 트리  
   - 여기에 노드의 왼쪽 자손은 더 작은 값을 가지고, 오른쪽 자손은 더 큰 값을 가지는 것을 이진 탐색 트리라고 함

2. 이진 탐색 트리 - 입력 예시
   - 이진 탐색 트리의 핵심은 데이터를 입력하는 시점에 정렬해서 보관한다는 점
   - 그리고 작은 값은 왼쪽에 큰 값은 오른쪽에 저장
   - 데이터 10, 5, 15, 1, 6, 11, 16을 순서대로 저장한다고 가정
      + 처음에 10을 입력했다고 가정하며, 다음으로 5, 15를 입력
<div align="center">
<img src="https://github.com/user-attachments/assets/5e3a90f4-188b-4038-bccd-0b429ed22b16">
</div>

   - 5 저장 : 5는 10보다 작으므로 왼쪽에 저장
   - 15 저장 : 15는 10보다 크므로 오른쪽에 저장
<div align="center">
<img src="https://github.com/user-attachments/assets/92d4f11e-6cb2-4998-bb4c-56e2a09252f4">
</div>

   - 1 저장 : 1은 10보다 작으므로, 따라서 왼쪽으로 찾아가며, 1은 5보다 작므로 따라서 왼쪽에 저장
   - 6 저장 : 6은 10보다 작으므로, 따라서 왼쪽으로 찾아가며, 6은 5보다 크므로 따라서 오른쪽에 저장
<div align="center">
<img src="https://github.com/user-attachments/assets/58c40152-5436-4067-8d6e-8f518dcbc15f">
</div>

   - 11 저장 : 11은 10보다 크므로, 따라서 오른쪽으로 찾아가며, 11은 15보다 작으므로, 따라서 왼쪽에 저장
   - 16 저장 : 16은 10보다 크므로, 따라서 오른쪽으로 찾아가며, 16은 15보다 크므로, 따라서 오른쪽에 저장

3. 이진 탐색 트리 - 검색
   - 작은 값은 왼쪽, 큰 값은 오른쪽으로 정렬된 상태로 저장된 트리 구조에서 데이터를 검색
<div align="center">
<img src="https://github.com/user-attachments/assets/baeb03c7-f8bc-4027-8f69-72b98d11d777">
</div>

   - 여기에는 총 15개의 데이터가 들어있으며, 여기서 숫자 35를 검색한다고 가정
     + 1번 : 루트인 20과 35를 비교하고, 35가 더 크므로 오른쪽으로 찾아감
     + 12번 : 40과 35를 비교하고, 35가 더 작으므로 왼쪽으로 찾아감
     + 13번 : 30과 35를 비교하고, 35가 더 크므로 오른쪽으로 찾아감
     + 14번 : 노드에 있는 값을 비교하고, 35와 같으므로 35를 찾음
   
   - 데이터가 총 15개인데 단 4번의 계산만으로 필요한 결과를 얻을 수 있음
   - 이진 탐색 트리 계산의 핵심은 한 번에 남은 절반을 날린 다는 점 : 계산을 단순화 하기 위해 16개의 데이터가 있다고 가정
     + 16개의 데이터가 있음 : 루트에서 처음 비교를 통해 절반의 데이터를 찾지 않아도 되므로, 따라서 16 / 2 = 8
     + 8개의 데이터가 있음 : 비교를 통해 절반의 데이터만 남게 되므로, 따라서 8 /2 = 4
     + 4개의 데이터가 있음 : 비교를 통해 절반의 데이터만 남게 되므로, 따라서 4 / 2 = 2
     + 2개의 데이터가 있음 : 비교를 통해 절반의 데이터만 남게 되므로, 따라서 2 / 2 = 1
     + 1이 남았으므로 이 값이 맞는지 확인하면 됨

4. 이진 탐색 트리의 빅오 - O(log n)
   - 16개의 경우 단 4번의 비교 만으로 최종 노드에 도달할 수 있음
      + 2개의 데이터 2로 1번 나누기 : log₂(2)=1
      + 4개의 데이터 2로 2번 나누기 : log₂(4)=2
      + 8개의 데이터 2로 3번 나누기 : log₂(8)=3
      + 16개의 데이터 2로 4번 나누기 : log₂(16)=4
      + 32개의 데이터 2로 5번 나누기 : log₂(32)=5
      + 64개의 데이터 2로 6번 나누기 : log₂(64)=6
      + ...
      + 1024개의 데이터 2로 10번 나누기 : log₂(1024)=10
      + 16,384개의 데이터 2로 14번 나누기 : log₂ (16384)=14
      + 65,536개의 데이터 2로 16번 나누기 : log₂ (65536)=16
      + 131,072개의 데이터 2로 17번 나누기 : log₂ (131072)=17
      + 1,000,000개의 데이터 2로 약 20번 나누기 : log₂ (1,000,000)≈19.93
      + 10,000,000개의 데이터 2로 약 24번 나누기 : log₂ (10,000,000)≈23.22
      + 100,000,000개의 데이터 2로 약 27번 나누기 : log₂ (100,000,000)≈26.57

   - 1024개의 데이터를 단 10번의 계산으로 원하는 결과를 찾을 수 있음
   - 데이터의 크기가 늘어나도 늘어난 만큼 한 번의 계산에 남은 절반을 날려버리기 때문에 데이터의 크기가 클 수록 효과적
   - 1억개의 데이터가 있어도 약 27번이면 원하는 데이터를 찾을 수 있음
   - 이 방식을 사용하면 1억개의 데이터가 있어도 처음 비교에서 이미 그 절반인 5000만건이 제거 : 가능한 이유는 데이터를 정렬한 상태로 보관하기 때문이며, 만약 정렬한 상태가 아니라면 이런 조회 방식은 불가능함
   - 이것을 수학으로 log₂(n) 으로 표현 : 쉽게 이야기해서 2로 몇 번 나누어서 1에 도달할 수 있는지를 계산하면 된다.

5. 이진 탐색 트리 - 순회
   - 이진 탐색 트리의 핵심은 입력 순서가 아니라, 데이터의 값을 기준으로 정렬해서 보관한다는 점  
   - 정렬해서 보관했기 때문에 정렬된 순서로 데이터를 차례로 조회할 수 있음 (순회 할 수 있음)
   - 데이터를 차례로 순회하려면 중위 순회라는 방법을 사용하면 됨
     + 왼쪽 서브트리를 방문한 다음, 현재 노드를 처리하고, 마지막으로 오른쪽 서브트리를 방문
     + 이 방식은 이진 탐색 트리의 특성상, 노드를 오름차순(숫자가 점점 커짐)으로 방문
<div align="center">
<img src="https://github.com/user-attachments/assets/017fc56c-33c4-4c0e-b07f-df7c5d57ffb5">
</div>

   - 중위 순회 순서
     + 쉽게 이야기해서 자신의 왼쪽의 모든 노드를 처리하고, 자신의 노드를 처리하고, 자신의 오른쪽 모든 노드를 처리하는 방식
     + 10의 기준에서 왼쪽 서브트리를 방문
        * 5의 기준에서 왼쪽 서브트리를 방문 : 1을 출력한다.
        * 5 자신을 출력
        * 5의 기준으로 오른쪽 서브트리를 방문 : 6을 출력
     + 10 자신을 출력
     + 10의 기준에서 오른쪽 서브트리를 방문
        * 15의 기준에서 왼쪽 서브트리를 방문 : 11을 출력
        * 15 자신을 출력
        * 15의 기준으로 오른쪽 서브트리를 방문 : 16을 출력
  - 순서대로 오름차순인 1, 5, 6, 10, 11, 15, 16이 출력된 것을 확인할 수 있음
  - 참고로 자신의 오른쪽 노드부터 순회하면 반대로 내림차순인 16, 15, 11, 10, 6, 5, 1 순으로 출력할 수 있음

6. 밸런스 트리(Balanced Tree)
  - 이진 탐색 트리의 검색, 삽입, 삭제의 평균 성능은 앞서 살펴본 것 처럼 O(log n)
  - 하지만 트리의 균형이 맞지 않으면 최악의 경우 풀 테이블 스캔과 같은 O(n)의 성능이 나옴 : O(n)은 10개의 데이터가 있다면 최악의 경우 10번의 탐색이 필요하다는 뜻
  - 만약 데이터를 1, 5, 6, 10, 15 순서로 입력했다고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/f38e6185-3c11-42e8-a202-d9e39d592dd1">
</div>

   - 이 경우 추가하는 값이 계속 오른쪽으로 입력
   - 이렇게 오른쪽으로 치우치게 되면, 결과적으로 15를 검색 했을 때 데이터의 수인 5만큼 검색을 해야함
   - 이것은 성능상 풀 테이블 스캔과 같음 : 이처럼 최악의 경우 O(n) 의 성능이 나옴

7. 이진 탐색 트리 개선
   - 이런 문제를 해결하기 위한 다양한 해결 방안이 있는데 트리의 균형이 너무 깨진 경우 동적으로 균형을 다시 맞추는 것
<div align="center">
<img src="https://github.com/user-attachments/assets/a9f777d4-c672-4e88-80eb-c40c6b47922a">
</div>

   - 예를 들어 앞서 본 트리에서 중간에 있는 6을 기준으로 다시 정렬
   - 이렇게 균형을 유지하는 트리를 밸런스 트리(Balanced Tree)
   - 대부분의 관계형 데이터베이스는 인덱스에 밸런스 트리를 사용해서 균형을 유지
   - 따라서 최악의 경우에도 O(log n)의 성능을 제공

8. 실제 인덱스에 사용되는 트리
   - 인덱스는 트리 구조를 사용하기 때문에 정렬된 상태로 저장
   - 예를 들어 item_name 컬럼을 기준으로 인덱스를 만들면 다음과 같이 item_name 컬럼이 정렬된 상태로 저장
   - 그리고 인덱스에는 인덱스에 사용할 값(item_name)과 원본 데이터의 위치가 하나의 쌍으로 저장
   - 이전에 보았던 트리 구조에서 item_name과 원본 데이터의 위치를 함께 보관한다고 생각하면 됨 (물론 트리 구조에 데이터를 보관하기 위해 비교할 때는 item_name 컬럼만 사용)
   - item)name 기준 인덱스
<div align="center">
<img src="https://github.com/user-attachments/assets/d104d39f-7aaf-4497-a8eb-abe0d9f2dab5">
</div>

9. 인덱스는 실제로는 B-Tree 구조이지만, 개념적으로는 표와 같이 정렬된 목록으로 이해할 수 있음
   - 대부분의 주요 관계형 데이터베이스 시스템은 인덱스를 구현하기 위해 앞서 설명한 이진 트리를 개선한 B-트리 또는 B트리의 변형(B+트리 등)을 사용
   - 이진 탐색 트리는 검색에 O(log n) 의 성능을 제공하지만, 데이터가 순차적으로 입력되면 한쪽으로 치우쳐지는 문제(Worst Case O(n))가 발생할 수 있음
   - 이 문제를 해결하기 위해 밸런스 트리(Balanced Tree) 개념이 도입되었고, B-트리는 이러한 밸런스 트리의 한 종류
   - 하지만 B-트리가 특별히 중요한 이유는 단순히 균형을 유지하는 것을 넘어, 데이터베이스처럼 대용량 데이터를 다루는 환경에 최적화되어 있기 때문임
   - 데이터베이스는 데이터를 메모리가 아닌 디스크에 저장 : 디스크에서 데이터를 읽는 작업(Disk I/O)은 메모리에서 읽는 것보다 훨씬 느림
   - 따라서 디스크 I/O 횟수를 줄이는 것이 성능에 결정적인 영향을 미침
   - 이진 탐색 트리는 한 노드가 하나의 데이터만 가지고 있어, 데이터를 검색할 때 여러 노드를 방문해야 한다면 그만큼 디스크에서 많은 블록을 읽어야 함
   - 반면 B-트리는 하나의 노드가 여러 개의 자식 노드를 가질 수 있고, 더 많은 데이터를 저장할 수 있도록 설계되었음
   - 이는 디스크에서 한 번 데이터를 읽을 때 더 많은 정보를 가져올 수 있게 하여 디스크 I/O 횟수를 획기적으로 줄여줌
   - 덕분에 B-트리는 디스크 I/O를 최소화하면서 대용량 데이터에서 효율적인 검색 성능을 제공
