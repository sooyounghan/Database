-----
### 트랜잭션이 필요한 이유
-----
1. 데이터의 일관성을 위협하는 것은 잘못된 '상태'뿐만이 아닌, 데이터를 변경하는 '행위'의 과정에서 문제가 생길 수도 있음
   - 쇼핑몰에서 고객이 '주문하기' 버튼을 누르는, 가장 중요하고 흔한 시나리오 가정 : 이 하나의 비즈니스 행위 뒤에서, 데이터베이스는 최소한 두 가지의 중요한 작업을 순차적으로 처리해야 함
      + 작업 1 : orders 테이블에 새로운 주문 정보를 INSERT
      + 작업 2 : products 테이블에서 방금 주문된 상품의 재고(stock_quantity)를 UPDATE 하여 1만큼 줄임 (정확히는 주문 수만큼 줄임)

   - 이 두 작업은 논리적으로 절대 쪼개질 수 없는 하나의 묶음

2. 트랜잭션이 없을 경우
   - 만약 이 두 작업이 아무런 안전장치 없이 그냥 순서대로 실행된다고 가정
   - 시나리오 : 1번 작업은 성공, 2번 작업은 실패
      + INSERT 쿼리로 orders 테이블에 새로운 주문이 성공적으로 기록
      + 이제 UPDATE 쿼리로 products 테이블의 재고를 줄이려는 바로 그 찰나, 애플리케이션 서버에 문제가 발생하거나, 데이터베이스 서버의 전원이 나가거나, 네트워크 연결이 끊기거나, 디스크에 오류가 발생하는 등 예기치 못한 문제가 발생하여 2번 작업이 실패했을 경우
      + 데이터베이스는 다음과 같은 아주 위험한, 일관성이 깨진(inconsistent) 상태에 빠지게 됨
        * orders 테이블 : 주문이 기록 (회사는 돈을 받을 것이고, 고객은 물건을 받을 것이라 기대)
        * products 테이블 : 재고가 줄어들지 않음 (회사는 여전히 팔 수 있는 재고가 있다고 착각)

      + 재고 관리의 실패 : 실제로는 팔린 상품을 계속 판매 가능한 재고로 인식하여, 결국 재고가 없는데도 주문을 받는 '초과 판매' 상황이 발생
      + 고객 신뢰도 하락 : 재고가 없어 주문을 취소당한 고객은 우리 쇼핑몰에 대한 신뢰를 잃게 됨
      + 잘못된 데이터 분석 : 모든 매출, 재고 관련 리포트가 실제와 달라지므로 믿을 수 없게 됨

   - 반대의 경우도 마찬가지 : 2번 재고 감소가 먼저 성공하고, 1번 주문 기록이 실패하면 '주문자는 없는데 재고만 사라진' 유령 재고가 발생

3. 해결책 : 트랜잭션 (Transaction)
   - 트랜잭션 : 논리적으로 절대 쪼개질 수 없는 하나 이상의 데이터베이스 작업 묶음(Unit of Work)을 의미
   - 원칙 : '전부 아니면 전무(All or Nothing)' 라는 원칙
     + 트랜잭션으로 묶인 작업들은 모두 다 성공해야만 그 결과를 실제 데이터베이스에 영구적으로 반영
     + 만약 작업 그룹 내에서 단 하나의 작업이라도 실패하면, 그전에 성공했던 모든 작업들을 전부 없었던 일로 되돌려버림

   - 우리의 주문 처리 시나리오를 트랜잭션으로 묶으면 이렇게 동작
     + 주문 처리 트랜잭션을 시작한
     + INSERT 문으로 orders 테이블에 주문을 기록 (성공)
     + UPDATE 문으로 products 테이블의 재고를 줄임 (실패!)
     + 하나의 작업이라도 실패했으므로, 트랜잭션은 실패로 간주
     + 데이터베이스는 2번에서 성공했던 INSERT 작업까지 자동으로 취소(원상 복구)시킴
     + 결과적으로, orders 테이블과 products 테이블은 이 트랜잭션이 시작되기 전의 완벽하게 일관된 상태로 남게 됨

   - 트랜잭션은 이 'All or Nothing' 원칙을 통해, 어떠한 외부 장애 상황에서도 데이터베이스의 일관성과 안정성을 보장하는 핵심적인 안전장치
