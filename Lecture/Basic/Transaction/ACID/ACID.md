-----
### 트랜잭션의 ACID 속성
-----
1. 'All or Nothing'은 트랜잭션이 보장하는 4가지 특성 중 하나일 뿐임
2. 데이터베이스 시스템 이론에서는 트랜잭션이 신뢰성을 갖추도록 반드시 지켜야 할 4가지 속성을 묶어 ACID라는 약어로 부름
   - ACID는 모든 관계형 데이터베이스 시스템의 근간을 이루는 매우 중요한 개념
   - ACID는 다음 네 단어의 첫 글자를 딴 것
      + Atomicity (원자성)
      + Consistency (일관성)
      + Isolation (격리성)
      + Durability (지속성)

   - 이 네 가지 속성이 모두 보장될 때, 우리는 비로소 그 데이터베이스의 트랜잭션을 '신뢰할 수 있다'고 말함
   
3. A : Atomicity (원자성) - 트랜잭션은 하나의 원자(Atom)처럼 더 이상 쪼갤 수 없는 논리적 단위이며, 전부 성공하거나 전부 실패
   - 'All or Nothing' 원칙
   - 계좌이체라는 트랜잭션은 'A 계좌 출금'과 'B 계좌 입금'이라는 두 개의 작업으로 이루어지지만, 데이터베이스는 이 둘을 하나의 원자적 작업으로 취급
      + 모두 성공 (COMMIT) : 출금과 입금이 모두 성공적으로 끝나야만, 이체라는 트랜잭션 전체가 성공으로 기록
      + 모두 실패 (ROLLBACK) : 출금은 성공했지만 입금이 실패하면, 성공했던 출금 작업까지 모두 취소되어 트랜잭션 전체가 실패로 돌아감
      + 원자성 덕분에, 돈이 A의 계좌에서 사라졌는데 B의 계좌에는 나타나지 않는 '돈이 증발하는' 상태는 절대 발생하지 않음

4. C : Consistency (일관성) - 트랜잭션이 성공적으로 완료되면, 데이터베이스는 항상 일관된(valid) 상태를 유지해야 함
   - 일관성은 트랜잭션의 실행 결과가 데이터베이스에 설정된 모든 규칙(제약 조건 등)을 위반하지 않음을 보장하는 속성
   - 계좌이체 예시 : 트랜잭션 시작 전, A(5만원)와 B(2만원) 계좌의 총액은 7만원이었다. 성공적인 트랜잭션(COMMIT) 후, A(4만원)와 B(3만원) 계좌의 총액은 여전히 7만원
     + 트랜잭션이 시스템의 전체 돈의 총량을 바꾸지 않는다는 '일관성'을 유지
     + 제약 조건 예시 : 만약 accounts 테이블에 CHECK (balance >= 0)이라는 제약 조건이 있다면, 잔고를 음수로 만드는 어떠한 트랜잭션도 결국 실패하고 ROLLBACK 될 것인데, 이로써 데이터베이스는 '잔고는 0 이상이어야 한다'는 일관성을 항상 지킬 수 있음
   - 💡 원자성이 '과정'의 완결성을 보장한다면, 일관성은 '결과'의 유효성을 보장하는 속성

5. I : Isolation (격리성) - 하나의 트랜잭션이 실행 중일 때, 다른 트랜잭션이 해당 트랜잭션의 중간 결과에 끼어들어 간섭할 수 없음
   - 격리성은 여러 트랜잭션이 동시에 실행될 때, 마치 각각의 트랜잭션이 순서대로 하나씩 실행되는 것처럼 느끼게 해주는 특성
   - 상황 : A는 50000원 B는 20000원이 있고, A가 B에게 1만원을 이체하는 트랜잭션(T1)을 실행 중
      + UPDATE로 A의 잔고는 4만원으로 바뀌었지만, 아직 COMMIT은 하지 않아 B의 잔고는 2만원인 '중간 상태'
      + 바로 그 순간 : 옆 창구에서 은행 직원이 전체 고객의 총잔고를 계산하는 트랜잭션(T2)을 실행
      + 격리성이 없다면, T2는 A의 잔고를 4만원으로, B의 잔고를 2만원으로 읽어서 총액이 6만원이라는 잘못된 결과를 얻게 됨
        * T1의 아직 완료되지 않은 불안정한 상태를 본 것 (이를 더티 리드(Dirty Read)라고 함)
      격리성이 있다면, T2는 T1이 아직 COMMIT 되지 않았기 때문에, T1이 임시로 변경한 내용을 보지 못함
        * T2는 T1이 시작되기 전의 값, 즉 A의 잔고 5만원과 B의 잔고 2만원을 읽어서 정확한 총액 7만원을 계산해냄

6. 격리성 - 격리성이 없는 경우
<div align="center">
<img src="https://github.com/user-attachments/assets/b4e21726-2393-4912-8129-9d9916adc8a3">
</div>

   - A가 B에게 1만원을 이체하는 트랜잭션(T1)을 실행 중
     + UPDATE로 A의 잔고는 4만원으로 바뀌었지만, 아직 COMMIT은 하지 않아 B의 잔고는 2만원인 '중간 상태' (그림에서 오른쪽의 [50000]의 값은 변경 전의 원본 값)
   - 바로 그 순간 옆 창구에서 은행 직원이 전체 고객의 총잔고를 계산하는 트랜잭션(T2)을 실행
   - 격리성이 없다면, T2는 A의 잔고를 4만원으로, B의 잔고를 2만원으로 읽어서 총액이 6만원이라는 잘못된 결과를 얻게 됨
     + T1의 아직 완료되지 않은 불안정한 상태를 본 것 (이를 더티 리드(Dirty Read)라고 함)
   - T1은 B의 값에 10000원을 더함 (그림에서 [20000]의 값은 변경 전의 원본 값)
   - 트랜잭션을 커밋
   - 전체 잔고를 다시 계산해보면 70000원이 됨
   - 여기서 문제가 발생한 이유는 T1이 원자적인 트랜잭션 작업을 하는 도중에 T2가 끼어들어서 T1의 값들을 볼 수 있기 때문임
   - 결국 하나의 트랜잭션이 실행 중일 때, 다른 트랜잭션이 해당 트랜잭션의 중간 결과를 볼 수 있기 때문임
   - 이 문제를 해결하려면 T1의 트랜잭션 작업을 다른 트랜잭션인 T2가 볼 수 없게 격리해야 함

7. 격리성 - 격리성이 있는 경우
<div align="center">
<img src="https://github.com/user-attachments/assets/b7aacfd2-9732-4331-a088-7f47b4e04192">
</div>

   - A가 B에게 1만원을 이체하는 트랜잭션(T1)을 실행 중
     + UPDATE로 A의 잔고는 4만원으로 바뀌었지만, 아직 COMMIT은 하지 않아 B의 잔고는 2만원인 '중간 상태' (그림에서 [50000] 의 값은 변경 전의 원본 값)
   - 바로 그 순간 옆 창구에서 은행 직원이 전체 고객의 총잔고를 계산하는 트랜잭션(T2)을 실행
   - 격리성이 있다면, T2는 T1이 아직 COMMIT 되지 않았기 때문에, T1이 임시로 변경한 내용을 보지 못함
     + T2는 T1이 시작되기 전의 값, 즉 A의 잔고 5만원과 B의 잔고 2만원을 읽어서 정확한 총액 7만원을 계산해냄

   - T1은 B의 값에 10000원을 더함 (그림에서 [20000] 의 값은 변경 전의 원본 값)
   - 트랜잭션을 커밋
   - 전체 잔고를 다시 계산해보면 70000원이 됨

   - 여기서는 T1이 원자적인 트랜잭션 작업을 하는 도중에 T2가 끼어들어서 T1의 값들을 볼 수 없음
   - 결국 하나의 트랜잭션이 실행 중일 때, 다른 트랜잭션이 해당 트랜잭션의 중간 결과를 볼 수 없는 것
   - 각각의 트랜잭션이 작업 중일 때 서로의 값을 볼 수 없게 격리한 덕분에 정상적인 값을 계산해 낼 수 있었음
   - 이처럼 격리성은 여러 사용자가 동시에 데이터베이스에 접근하는 환경에서 데이터가 엉망이 되는 것을 막아주는 매우 중요한 속성

8. D: Durability (지속성) - 성공적으로 완료되어 COMMIT된 트랜잭션의 결과는, 시스템에 장애가 발생하더라도 영구적으로 보존
   - 지속성은 COMMIT 된 데이터는 절대 사라지지 않는다는 약속
   - 상황 : A가 B에게 성공적으로 1만원을 이체하고, 은행 앱에서 "이체 완료" 메시지를 확인 (COMMIT 성공)
      + 1초 뒤 : 은행의 전체 전산 시스템이 다운되었다.
   - 지속성 보장 : 시스템이 재부팅된 후에도, A의 잔고는 4만원, B의 잔고는 3만원인 상태가 그대로 유지되어 있어야 함
     + COMMIT 된 결과는 데이터베이스의 저장소(SSD, HDD)에 있는 트랜잭션 로그 등에 기록되어, 어떤 장애에도 살아남을 수 있음

9. 이 네 가지 ACID 속성이 있기에, 우리는 안심하고 은행 거래를 하고, 쇼핑몰에서 주문을 하고, 데이터베이스의 소중한 데이터를 맡길 수 있는 것
10. 이 중, 특히 '격리성'은 "어느 정도로 엄격하게 격리(고립)시킬 것인가?"에 따라 몇 가지 단계, 즉 격리 수준(Isolation Level)으로 나뉨
    - 완벽하게 격리시키면 데이터는 매우 안전하지만 동시에 많은 작업을 처리하기 어려워져 성능이 저하되고, 격리 수준을 낮추면 성능은 올라가지만 특정 데이터 불일치 문제가 발생할 수 있음
