-----
### 트랜잭션 격리 수준
-----
1. 격리성은 여러 트랜잭션이 동시에 실행될 때 서로 간섭하지 못하게 막아주는 중요한 속성
2. 만약 모든 트랜잭션이 완벽하게 격리(고립)되어, 마치 한 줄로 줄을 서서 한 번에 하나씩만 순서대로 실행된다면 데이터는 매우 안전할 것
   - 하지만 수천, 수만 명의 사용자가 동시에 접속하여 주문하고, 상품을 조회하는 온라인 쇼핑몰의 경우, 아마 거북이처럼 느려져서 아무도 사용하지 않으려 할 것
   - 이것이 바로 데이터베이스 개발자가 항상 마주하는 중요한 트레이드오프

3. 데이터 정합성(Correctness) vs 동시성 / 성능(Concurrency / Performance)
   - 데이터베이스는 이 트레이드오프를 개발자가 직접 '조절'할 수 있도록 트랜잭션 격리 수준(Transaction Isolation Level)이라는 몇 가지 단계를 제공
   - 격리 수준을 높이면(엄격하게 만들면) 데이터 정합성은 올라가지만 동시성이 떨어져 성능이 저하되고, 격리 수준을 낮추면(느슨하게 만들면) 성능은 올라가지만 특정 데이터 부정합 문제가 발생할 수 있음
  
4. 💡 동시성 문제 (Concurrency Problems) - 격리 수준이 낮을 때 발생할 수 있는 대표적인 문제 현상(Anomaly)
   - 더티 리드 (Dirty Read)
      + 정의 : 한 트랜잭션이 아직 COMMIT 하지 않은, 수정 중인 데이터를 다른 트랜잭션이 읽는 것
      + 예시 : 트랜잭션 A가 특정 상품의 가격을 100원에서 120원으로 바꾸고 아직 COMMIT 하지 않았지만, 이때 트랜잭션 B가 이 상품의 가격을 조회했더니 '120원'이 보였음
        * 하지만 잠시 후 트랜잭션 A가 작업을 취소(ROLLBACK)해버리면, 가격은 다시 100원이 되어, 트랜잭션 B는 결국 존재하지도 않는 '더러운' 데이터를 읽은 셈

   - 반복 불가능 읽기 (Non-Repeatable Read)
      + 정의 : 한 트랜잭션 내에서 똑같은 SELECT 쿼리를 두 번 실행했는데, 그 사이에 다른 트랜잭션이 값을 수정 하고 COMMIT 하는 바람에 두 쿼리의 결과가 다르게 나오는 현상
      + 예시 : 트랜잭션 A가 특정 상품의 재고 필드 값이 '10개'인 것을 확인한 뒤, 잠시 다른 작업을 하다가 다시 재고를 확인했더니, 그 사이에 다른 트랜잭션 B가 그 상품을 하나 사가서 재고 필드 값이 '9개'로 바뀌어 있음
        * 트랜잭션 A 안에서 같은 데이터의 반복 조회가 불가능해진 것

   - 유령 읽기 (Phantom Read)
      + 정의: 한 트랜잭션 내에서 특정 범위의 데이터를 두 번 읽었는데, 첫 번째 조회에서는 없었던 새로운 행(유령)이 두 번째 조회에서 나타나는 현상
        * 다른 트랜잭션이 새로운 행을 INSERT하고 COMMIT 했기 때문에 발생
      + 예시: 트랜잭션 A가 '전자기기' 카테고리의 상품 수를 세었더니 '5개'였지만, 잠시 후 똑같이 수를 세었더니, 그 사이에 다른 트랜잭션 B가 새로운 '전자기기' 상품을 등록해서 '6개'가 되었음 (없었던 유령 상품이 나타난 것)

5. 💡 4가지 표준 격리 수준 : SQL 표준은 이러한 문제들을 방지하는 강도에 따라 4가지 격리 수준(Isolation Level)을 정의
   - 아래로 갈수록 격리 수준이 높아지고, 성능은 떨어짐
<div align="center">
<img src="https://github.com/user-attachments/assets/2358aaeb-71e1-4ae3-a839-ccee72cbfd22">
</div>

   - READ UNCOMMITTED : 거의 아무것도 막아주지 않는, 가장 낮은 수준으로, 정합성 이슈가 많아 거의 사용되지 않음
   - READ COMMITTED : 더티 리드를 방지하며, 즉, COMMIT 된 데이터만 읽을 수 있으며, 오라클, SQL Server 등 많은 데이터베이스의 기본 격리 수준
   - REPEATABLE READ : 한 트랜잭션 안에서는 데이터의 일관된 조회를 보장해주며, MySQL의 InnoDB 스토리지 엔진이 사용하는 기본 격리 수준
   - SERIALIZABLE : 가장 엄격한 수준으로, 동시성 문제를 완벽하게 차단하지만, 트랜잭션을 거의 순서대로 실행시켜 동시 처리 성능이 가장 낮음

6. 최신 MySQL은 InnoDB 스토리지 엔진을 기본으로 사용

7. 💡 심화 - MySQL InnoDB 특징
   - SQL 표준에 따르면 REPEATABLE READ 수준에서는 팬텀 리드(Phantom Read)가 발생할 수 있다고 정의
   - MySQL의 InnoDB 엔진은 MVCC와 갭 락(Gap Lock)이라는 기술을 통해 REPEATABLE READ 수준에서도 대부분의 팬텀 리드가 발생하는 것을 막아줌
   - 이 때문에 InnoDB의 REPEATABLE READ는 표준의 SERIALIZABLE에 가까운 격리성을 제공 (가깝다는 것이지 완벽한 것은 아님)

-----
### 격리 수준 확인 및 변경하기
-----
1. 현재 격리 수준 확인 : 현재 세션(연결)의 격리 수준을 확인하는 쿼리
```sql
SELECT @@transaction_isolation;
```
<div align="center">
<img src="https://github.com/user-attachments/assets/dee2be00-e340-454a-901f-3b60da09cfb5">
</div>

2. 격리 수준 변경
   - 격리 수준은 특정 트랜잭션에만 적용하거나, 현재 세션 내내 적용하거나, 데이터베이스 시스템 전체에 적용할 수 있음
   - 현재 세션에서만 변경하기 (가장 일반적) : SET SESSION 옵션을 사용하면, 지금 내가 접속한 이 세션에만 격리 수준이 변경 (다른 개발자나 사용자에게는 영향을 주지 않으므로 비교적 안전)
```sql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
```
```sql
SELECT @@transaction_isolation;
```
<div align="center">
<img src="https://github.com/user-attachments/assets/7fa4059e-86c5-4749-8f12-8b282de087f0">
</div>

   - READ-COMMITTED으로 변경

3. 글로벌(전역)으로 변경하기 (주의)
   - SET GLOBAL은 데이터베이스 서버의 기본 격리 수준 자체를 변경 (이후에 연결되는 모든 세션에 영향)
```sql
SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;
```
   - SET GLOBAL 명령어는 서버 재시작 시 사라지는 임시적인 설정
   - 이 설정을 영구적으로 설정하려면 MySQL 설정 파일(my.cnf 또는 my.ini)을 변경해야 함
   - 시스템 전체에 영향을 주는 변경은 매우 신중해야 하므로, 특별한 정책이 있지 않다면 기본값을 따르는 것이 좋음

-----
### 실무 팁: 어떤 격리 수준을 선택해야 할까?
-----
1. 특별한 이유가 없다면 MySQL의 기본 격리 수준인 REPEATABLE READ를 그대로 사용하는 것을 권장
   - 트래픽이 매우 많고 단순 조회 위주의 웹 애플리케이션이라면 READ COMMITTED을 고려할 수 있음
   - REPEATABLE READ는 데이터 정합성과 동시성 사이에서 매우 합리적인 균형을 제공
     + 한 트랜잭션이 시작되면 그 트랜잭션이 끝날 때까지 다른 트랜잭션의 변경 사항에 영향을 받지 않고 일관된 데이터를 조회할 수 있음
     + 심지어 MySQL의 InnoDB 엔진은 갭 락(Gap Lock) 덕분에 다른 데이터베이스라면 막지 못했을 팬텀 리드까지 대부분 막아주니, 웬만한 비즈니스 로직에서는 충분히 안정적

2. 그렇다면 언제 다른 격리 수준을 '고민' 해볼 수 있을까?
   - READ UNCOMMITTED로 낮추는 것을 고려하는 경우
      + 이 격리 수준은 실무에서 거의 사용하지 않는데, 커밋되지 않은, 즉 언제든 사라질 수 있는 '더러운' 데이터(Dirty Data)를 읽는 것을 허용하기 때문임
      + 이는 데이터 정합성에 매우 심각한 문제를 일으킬 수 있음
      + 그리고 MySQL을 포함한 현대의 데이터베이스들은 다양한 최적화 기법을 제공하기 때문에 다음 단계인 READ COMMITTED와 성능 차이가 거의 나지 않음 (약 0 ~ 3%)
      + 물론 이론적이긴 하지만, 아주 예외적인 상황에서, 성능 향상을 위해 '정확성'을 어느 정도 희생할 수 있을 때만 제한적으로 고려해 볼 수 있음 (바로 대용량 데이터에 대한 실시간 집계나 통계 작업을 수행할 때)
          * 쇼핑몰의 items 테이블에 수억 개의 상품이 있고, 마케팅팀에서 '전자기기' 카테고리 상품의 대략적인 평균 가격 추이를 실시간으로 보고 싶어 한다고 가정
          * 이 경우, 몇몇 상품의 가격이 트랜잭션 도중 잠깐 바뀌었다가 롤백되더라도 전체 평균 가격에 미치는 영향은 아주 미미할 것
          * 마케팅팀에 필요한 것은 회계 장부처럼 1원 단위까지 정확한 수치가 아니라, 현재 시장의 '경향성'을 파악하는 것이기 때문임
          * 이럴 때 READ UNCOMMITTED 를 사용하면, 다른 트랜잭션이 특정 상품의 가격을 수정하는 동안 락(Lock)을 기다리지않고 즉시 데이터를 읽어올 수 있음

    - 예시
      + 트랜잭션 1 (운영팀) : '게이밍 노트북' 가격을 1,500,000원에서 1,450,000원으로 변경하는 작업을 시작 (아직 커밋(COMMIT)은 하지 않았음)
```sql
-- 트랜잭션 시작
START TRANSACTION;

UPDATE items
SET price = 1450000
WHERE item_name = '게이밍 노트북';
```
   - 트랜잭션 2 (마케팅팀 분석 쿼리) : 바로 그 시점에, READ UNCOMMITTED 격리 수준으로 설정된 트랜잭션에서 '전자기기'의 평균 가격을 조회
```sql
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```
```sql
SELECT AVG(price)
FROM items
WHERE category = '전자기기';
```
   - 이 쿼리는 트랜잭션 1이 아직 커밋하지 않은 1,450,000원이라는 가격을 그대로 읽어서 평균을 계산
   - 트랜잭션 1 (운영팀) : 운영팀 직원이 실수를 깨닫고 작업을 취소(ROLLBACK)하면서, '게이밍 노트북' 가격은 원래대로 1,500,000원으로 돌아감
```sql
ROLLBACK;
```
   - 결과적으로 마케팅팀이 본 평균 가격은 '세상에 잠시 존재했다가 사라진' 유령 데이터를 기반으로 계산된 것
   - 하지만 수만 개의 '전자기기' 상품 중 단 하나의 데이터가 잠시 바뀐 것이 전체 평균에 큰 영향을 주지는 않으며, 빠른 응답 속도가 더 중요한 가치일 수 있음
     + 하지만, 이는 매우 위험한 선택 : 주문 처리, 재고 관리, 고객 정보 조회와 같이 데이터의 정확성이 생명인 핵심 비즈니스 로직에서는 절대 사용해서는 안 됨
     + Dirty Read 로 인해 고객에게 잘못된 가격을 보여주거나 재고가 있는데도 없다고 판단하는 등의 끔찍한 상황이 발생할 수 있음

   - 결론적으로 READ UNCOMMITTED는 '이런 것도 있구나' 정도로만 알아두고, 실무에서는 사용을 지양하는 것이 현명
   - 통계나 분석 작업이 필요하다면, 운영 데이터베이스(Source a.k.a Primary)를 복제한 분석용 데이터베이스(Replica)를 따로 구축해서 그곳에서 자유롭게 쿼리를 실행하는 것이 훨씬 더 안전하고 일반적인 방법

   - READ COMMITTED로 낮추는 것을 고려하는 경우
     + 성능과 동시성 확보가 매우 중요하고, 약간의 데이터 비일관성을 감수할 수 있는 특정 상황에서 READ COMMITTED 를 선택할 수 있음
     + 많은 온라인 서비스, 특히 웹 애플리케이션은 '하나의 요청 = 하나의 짧은 트랜잭션'으로 동작하는 경우가 대부분
     + 예를 들어, 사용자가 상품 목록을 조회하면, 서버는 DB에서 상품 목록을 조회해서 반환하고 트랜잭션을 바로 종료
        * 이런 환경에서는 트랜잭션 하나에서 똑같은 SELECT 쿼리를 여러 번 실행할 일이 거의 없으므로, Non-Repeatable Read가 발생할 가능성 자체가 낮음
        * 이럴 때 READ COMMITTED를 사용하면 불필요한 락(Lock)들을 사용하지 않게 되어 락(Lock)을 기다리는 시간이 줄어듬
        * 결과적으로 데이터베이스의 전체적인 처리량(Throughput)이 향상될 수 있음 : 오라클(Oracle), PostgreSQL, SQL Server와 같은 다른 인기 있는 데이터베이스들이 READ COMMITTED를 기본값으로 채택한 이유

     + 성능 향상은 애플리케이션의 성격에 따라 다르지만, 업데이트와 입력이 빈번하게 발생하는 높은 동시성 환경에서는 대략 10% ~ 30% 수준의 처리량 향상을 기대해 볼 수 있으며, 경우에 따라 그 이상도 가능
     + 물론, 이는 일반적인 수치이며 실제로는 애플리케이션의 쿼리 패턴과 데이터 경쟁 정도에 따라 크게 달라질 수 있음

   - SERIALIZABLE로 높이는 것을 고려하는 경우
     + 데이터의 정합성이 극도로 중요해서 아주 작은 예외도 허용할 수 없을 때 사용
     + 이는 마치 트랜잭션을 한 줄로 세워 순서대로 처리하는 것과 유사하므로, 동시성이 크게 저하
     + 예를 들어, 여러 사용자가 동시에 하나의 은행 계좌에서 돈을 인출하려 하거나, 초당 수십 건의 주문이 몰리는 한정 수량 상품의 재고를 차감하는 로직이 있다면 SERIALIZABLE을 고려해볼 수 있음 (실무에서는 다른 대안을 선택)
     + 동시성이 현저히 떨어져서 시스템 전체 성능에 병목이 될 가능성이 매우 높음
     + 따라서 SERIALIZABLE은 정말 다른 방법이 없을 때 사용하는 최후의 수단으로 생각해야 함

3. 대부분의 경우, 격리 수준을 무작정 높이기보다는 애플리케이션 코드 레벨에서 SELECT ... FOR UPDATE 와 같은 비관적 락(Pessimistic Lock)을 사용하거나, 버전 번호를 두는 낙관적 락(Optimistic Lock)을 구현하여 문제를 더 정교하게 해결하는 것이 현명한 선택
   - 이런 이유로 SERIALIZABLE은 실무에서 거의 사용하지 않음
   - 이러한 격리 수준은 데이터베이스의 동시성 제어(Concurrency Control)와 관련된 매우 깊이 있고 중요한 주제로, 각 수준의 동작 원리와 그에 따른 성능 특성을 이해하는 것은 고급 데이터베이스 개발자와 관리자에게 중요

