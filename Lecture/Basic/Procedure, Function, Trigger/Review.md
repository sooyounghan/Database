-----
### 정리
-----
1. 프로시저, 함수, 트리거 소개
   - SELECT , INSERT 와 같은 SQL 문을 묶어 데이터베이스 내에 프로그램처럼 저장하고 호출하기 위한 기능으로 저장 프로시저, 저장 함수, 트리거가 존재
   - 저장 프로시저 (Stored Procedure) : 이름이 부여된 SQL 작업 묶음으로, CALL 명령으로 호출하여 복잡한 비즈니스 로직을 처리
   - 저장 함수 (Stored Function): 특정 계산을 수행하고 반드시 '하나의 값'을 반환하는 프로그램으로, 쿼리문 안에서 내장 함수처럼 사용
   - 트리거 (Trigger): 특정 테이블에 INSERT , UPDATE , DELETE 같은 이벤트가 발생했을 때 자동으로 실행되는 프로그램
   - 과거에는 성능 향상, 코드 재사용 및 중앙화, 보안 강화 목적으로 자주 사용되었음

2. 프로시저, 함수, 트리거 실습
   - 저장 프로시저 실습 : 고객 주소 변경과 변경 이력 기록이라는 두 가지 작업을 sp_change_user_address 프로시저로 묶어 CALL 문으로 한 번에 실행
   - 저장 함수 실습 : 상품의 정가와 할인율로 최종 판매가를 계산하는 fn_get_final_price 함수를 만들어 SELECT 문에서 호출하여 사용
   - 트리거 실습 : users 테이블에서 데이터가 삭제되기 직전(BEFORE DELETE), 해당 고객 정보를 retired_users 테이블에 자동으로 백업하는 trg_backup_user 트리거를 생성하고 확인했
   - 이 기능들은 최근 실무에서 잘 사용되지 않으므로, 개념과 사용 방식 정도만 가볍게 이해하는 것을 권장

3. 데이터베이스 로직의 함정과 현대적 대안
   - 현대 개발에서 데이터베이스 로직 사용을 기피하는 이유는 유지보수, 성능, 확장성, 종속성 문제 때문임
     유지보수의 어려움 : 비즈니스 로직이 애플리케이션과 데이터베이스에 분산되어 추적이 어렵고, Git과 같은 버전관리가 까다로움
   - 성능 및 확장성 문제 : 로직이 데이터베이스에 집중되면 병목 현상이 발생하며, 수평 확장이 쉬운 애플리케이션 서버와 달리 데이터베이스는 확장이 어렵고 비용이 많이 발생
   - 데이터베이스 종속성 : 프로시저 등의 문법은 DB 제조사(Oracle, MS SQL, MySQL 등)마다 달라, 다른 데이터 베이스로 이전하는 것을 매우 어렵게 만듬(벤더 종속)
   - 현대의 대안 : 애플리케이션은 비즈니스 로직 처리를, 데이터베이스는 데이터 저장 및 관리에만 집중하도록 역할을 명확히 분리하는 것이 현대 아키텍처의 기본 원칙
