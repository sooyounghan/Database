-----
### 1단계 : 핵심 요구 사항 다시 정의하기 (MVP)
-----
1. MVP(Minimum Viable Product, 최소 기능 제품)를 정의하는 과정
   - 말 그대로, 필요한 최소한의 기능을 정의하는 것
   - 외부 판매자 기능 : 제외, 1차 목표는 우리 회사 상품을 온라인으로 판매하는 것
   - 쿠폰, 리뷰, 복잡한 카테고리 : 일단 없어도 주문은 가능하므로, 2차 오픈 기능으로 미룸
   - 장바구니 기능 : 매우 중요하지만, 굳이 데이터베이스에 저장할 필요는 없음
     + 우선은 애플리케이션이나 클라이언트(웹 브라우저) 측에 임시 보관하도록 구현할 수 있음
     + 데이터베이스 설계에서는 일단 제외

2. 꼭 필요한 핵심 기능 : 쇼핑몰 MVP 기능 명세서
   - 회원 : 고객이 가입하고 자신의 정보를 관리할 수 있어야 함
   - 상품 : 우리가 판매할 상품을 등록하고 관리할 수 있어야 함
   - 주문 : 회원이 상품을 구매할 수 있어야 함
   - 결제 : 주문에 대한 결제 정보를 기록하고 관리할 수 있어야 함
   - 배송 : '결제가 완료된' 주문의 배송 상태를 관리할 수 있어야 함

-----
### 2단계 : 핵심 엔티티 도출
-----
1. 회원(Member) : 서비스를 사용하는 고객
2. 상품(Product) : 판매의 대상이 되는 물건
3. 주문(Order) : 회원의 구매 활동 결과
4. 결제(Payment) : 주문에 대한 지불 정보
5. 배송(Delivery) : 주문된 상품의 물리적 이동에 대한 정보
6. 도출된 핵심 엔티티 : 회원, 상품, 주문, 결제, 배송
5. 주문과 배송 을 별도의 엔티티로 분리
   - 주문은 '결제'까지 포함하는 비즈니스 트랜잭션의 단위
   - 배송은 '물류'라는 별개의 프로세스
   - 이렇게 역할을 분리하면 나중에 "주문은 완료되었지만 배송은 시작 전"과 같은 다양한 상태를 명확하게 관리할 수 있고, 각자의 책임이 분명해져 시스템을 유지보수하기 쉬워짐

-----
### 3단계 : 속성 정의 및 관계 설정
-----
1. 회원(Member) : 회원id, 로그인id, 비밀번호, 회원명, 이메일, 주소
2. 상품(Product) : 상품id, 상품명, 상품 가격, 재고 수량
3. 주문(Order) : 주문id, 주문 상태, 배송지 주소, 주문 일시
4. 결제(Payment) : 결제id, 결제 수단, 결제 금액, 결제 상태, 결제 일시
5. 배송(Delivery) : 배송id, 배송 상태, 운송장 번호
6. 식별자(기본 키) 전략
   - 식별자는 단순화와 일관성을 위해 엔티티명 + id를 사용
   - 회원의 경우 회원id 와 로그인id 가 별도로 존재
     + 회원id는 회원을 저장할 때 마다 데이터베이스나 시스템이 절대 중복되지 않도록 임의로 만들어주는 식별자 값
     + 예를 들면 값이 하나씩 증가하는 자동 증가(Auto Increment) 같은 값을 사용하는 것
     + 로그인id는 사용자가 회원가입시에 입력한 로그인 하는데 필요한 id
     + 물론 여기서 로그인id , 이메일은 절대로 중복되지 않기 때문에 회원id를 제거하고, 대신에 로그인id이나 이메일 속성을 식별자로 사용해도 됨
   - 그럼에도 불구하고 왜 회원id 같은 임의의 id 값을 만들어서 식별자로 사용 : 식별자(기본 키)를 선택하는 전략은 데이터베이스 설계에서 가장 중요한 부분 중 하나

7. 관계
   - 회원과 주문의 관계 : 한 명의 회원 은 여러 번 주문 할 수 있음 (1:N 관계)
   - 주문과 결제의 관계 : 하나의 주문 에 대해 하나의 결제 가 이루어짐 (1:1 관계)
   - 주문과 배송의 관계 : 하나의 주문 에 대해 하나의 배송 이 이루어짐 (1:1 관계)
   - 주문과 상품의 관계 : 하나의 주문 에는 여러 상품 이 포함될 수 있으며, 반대로 하나의 상품도 여러 주문에 포함될 수 있음 (M:N 관계)

-----
### 4단계 : M:N 관계 해소와 '연관 엔티티'
-----
1. 가장 중요한 M:N 관계 : 주문과 상품의 관계
2. 앞서 연관 엔티티에서 배웠듯이 이런 다대다 관계는 다음과 같은 문제가 존재
   - 문제 1 : M:N 관계는 물리적으로 구현할 수 없음
   - 문제 2 : 관계에 속한 데이터를 저장할 장소가 없음
3. 이런 문제를 해결하기 위해 연관 엔티티를 도입해야 함
   - 두 엔티티의 관계 속에서만 의미를 가지는 속성이 있는가?
      + 어떤 회원이 'A상품'과 'B상품'을 하나의 주문서로 주문했다고 생각
      + 이때, 'A상품을 몇 개 주문했는가?'(주문 수량), 'A상품을 얼마에 주문했는가?'(주문 당시 가격)라는 정보가 필요

   - 주문 수량 : 이 정보는 주문 엔티티에 속하지 않으며, 주문 하나에는 상품이 여러 개일 수 있으니, 특정 상품의 수량을 저장할 수 없음
     + 상품 엔티티는 더더욱 아님

   - 주문 당시 가격 : 상품 엔티티에는 현재 상품 가격 정보가 있지만, 상품 가격은 언제든 바뀔 수 있음
     + 3일 전에 10,000원에 주문한 내역이 오늘 가격이 12,000원으로 올랐다고 해서 바뀌면 안 됨
     + 즉, 주문이 일어난 '시점'의 가격을 어딘가에 저장해야 함

   - 바로 이 주문 수량과 주문 당시 가격은 주문 과 상품의 관계 속에서만 의미를 갖는 데이터
   - 따라서 우리는 이 M:N 관계를 해소하고, 이 추가적인 데이터를 담을 새로운 테이블, 즉 연관 엔티티가 필요 : 이를 주문 항목(order_item) 
   - 이렇게 주문 항목 연관 엔티티를 도입하면, 복잡했던 M:N 관계는 두 개의 단순한 1:N 관계로 해결
   - 주문과 주문 항목의 관계 (1:N)
     + 하나의 주문은 여러 개의 주문 항목을 가질 수 있음
     + 하나의 주문 항목은 반드시 하나의 주문에 속함

   - 상품과 주문 항목의 관계 (1:N)
     + 하나의 상품은 여러 주문 항목에 포함될 수 있음
     + 하나의 주문 항목은 반드시 하나의 상품을 가짐

4. 정리
   - 주문 (1) - (N) 주문 항목 (N) - (1) 상품
   - 이렇게 주문 항목(order_item) 연관 엔티티를 도입하면, 복잡했던 M:N 관계는 단순한 일대다(1:N), 다대일(N:1) 관계로 해결

-----
### 참고: 연관 엔티티 추천 이름 및 특징
-----
1. 주문 항목(order_item)은 주문(order)과 상품(product)의 관계에서 나온 연관 엔티티
2. 연관 엔티티의 이름을 지을 때는 크게 2가지 방법 존재
    - 연결 강조 : 주문 상품(order_product)
      + '주문'과 '상품' 테이블을 직접적으로 연결한다는 관계를 이름에 명시적으로 보여줌
      + 매우 직관적이고 단순하여 관계를 파악하기 쉽다는 장점이 있음

    - 의미 있는 이름 : 주문 항목(order_item)
      + '주문'에 포함된 '항목'이라는 의미를 가장 명확하게 전달한
      + 실제 쇼핑몰 비즈니스 로직(예) 장바구니 항목, 주문 항목)과 용어가 일치하여 이해하기 쉬움

    - 의미 있는 이름 : 주문 상세(order_detail)
      + '주문의 상세 내역'이라는 의미로, order_item과 거의 동일한 의미로 널리 사용
      + 주문에 속한 각 상품 정보를 상세히 나타낸다는 점을 강조

    - 실무에서는 의미 있는 이름을 사용하는 것이 좋음
    - 데이터베이스는 단순히 데이터를 저장하는 창고가 아니라 비즈니스 모델을 반영하는 설계도이기 때문임
    - 만약 관계가 단순하고 의미 있는 이름을 짓기 어렵다면 양쪽 엔티티의 이름을 사용하는 연결을 강조하는 방식을 선택할 수 있음
