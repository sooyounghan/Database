-----
### 연관 엔티티 - 다대다 관계 해결
-----
1. M:N 관계의 두 가지 문제점과 해결책
<div align="center">
<img src="https://github.com/user-attachments/assets/4b794264-dea6-4ffc-af89-9d40f37f9618">
</div>

   - 주문과 상품의 관계가 M:N(다대다)이라고 결론 내음 : "하나의 주문에는 여러 상품이 포함될 수 있고, 하나의 상품은 여러 주문에 포함될 수 있다." 개념적으로는 타당
   - 그러나 이 모델을 가지고 실제 데이터베이스 테이블을 만들려고 하면 두 가지 큰 문제에 부딪치게 됨

2. 문제 1 : M:N 관계는 물리적으로 구현할 수 없음
   - 개념적으로 M:N 관계를 그리는 것은 쉽지만, 이것을 실제 데이터베이스의 테이블 구조로 옮길 수는 없음
   - 관계형 데이터베이스는 '테이블'이라는 2차원 표 형태를 사용하며, 관계는 한 테이블의 기본 키(Primary Key)를 다른 테이블의 외래 키(Foreign Key)로 포함시켜 표현
   - 이 방식을 M:N 관계에 적용
     + '네이트(회원id:1)'가 주문 1001번으로 상품 101(키보드)과 상품 102(마우스)를 주문한 상황
  - 시도 1 : 주문 테이블에 상품ID 컬럼 추가하기 (1:N 방식)
     + 주문 테이블에 주문한 상품의 ID를 저장
<div align="center">
<img src="https://github.com/user-attachments/assets/a9286fea-e663-4fca-93f4-87b490f36980">
</div>

   - 문제점 : 주문 1001에 키보드(101)를 담았더니, 마우스(102)를 담을 방법이 없음
     + 마우스를 담기 위해 새로운 주문 행을 만들면, 그것은 더 이상 주문 1001이 아니게 됨
     + 이 구조는 하나의 주문에 단 하나의 상품만 가질 수 있으므로 "여러 상품을 한 번에 주문"한다는 요구 사항을 만족시키지 못함

   - 시도 2 : 컬럼 계속 추가
     + 그렇다면 한 주문에 포함될 수 있는 상품의 최대 개수를 정해두고, 그만큼 컬럼을 미리 만들어두는 것은 어떨까?
     + 예를 들어 한 번에 최대 5개의 상품을 주문할 수 있다고 가정
     + 주문 테이블 (잘못된 설계)
<div align="center">
<img src="https://github.com/user-attachments/assets/6bef60ff-2252-4f68-b60f-54cc85ee0015">
</div>

   - 이 방법 역시 심각한 문제점을 가지고 있음
      + 확장성 부재 : 만약 어떤 고객이 한 번에 6개의 상품을 주문하고 싶다면 어떻게 해야 할까?
        * 데이터베이스 관리자는 ALTER TABLE 명령어로 product6_id 컬럼을 추가해야 함
        * 비즈니스의 요구 사항이 바뀔 때마다 데이터베이스의 구조를 변경해야 하는 것은 매우 딱딱하고 확장성 없는 설계

      + 공간 낭비 : 대부분의 주문은 한두 개의 상품으로 이루어질 것이
        * 5개의 컬럼을 만들어두면, 대다수 주문 데이터에서 product3_id, product4_id, product5_id 컬럼은 항상 NULL 값으로 채워져 저장 공간을 낭비하게 됨

      + 데이터 검색의 어려움 : "무소음 마우스(ID: 102)가 포함된 모든 주문을 찾아달라"는 간단한 요청에 대한 SQL이 매우 복잡
        * WHERE product1_id = 102 OR product2_id = 102 OR product3_id = 102 OR ... 와 같이 모든 컬럼을 OR 조건으로 엮어야 함
        * 이는 쿼리 성능을 저하시키고 유지보수를 어렵게 만들어버림
  
      + 이처럼 컬럼을 무한정 늘리는 방식은 근본적인 해결책이 될 수 없음

   - 시도 3 : 한 컬럼에 여러 값 넣기 (절대 피해야 할 방식)
      + 그렇다면 상품ids 라는 컬럼을 만들고, 여기에 주문한 상품 ID들을 텍스트로 모두 넣어보면 어떨까?
      + 주문 테이블 (잘못된 설계)
<div align="center">
<img src="https://github.com/user-attachments/assets/e2eb1237-1267-4541-95d2-a079bad3107a">
</div>

   - 문제점 : 이 방식은 관계형 데이터베이스의 근간을 흔드는 최악의 설계
     + 데이터 검색의 어려움 : "무소음 마우스(ID: 102)가 포함된 모든 주문을 찾아달라"는 간단한 요청에 상품ids LIKE '%102%' 와 같은 복잡하고 비효율적인 텍스트 검색을 해야 함
       * 만약 상품 ID가 1102라면 이것까지 함께 검색되는 끔찍한 오류가 발생할 수 있음
     + 데이터 수정 및 삭제의 복잡성 : 주문 1003에서 '모니터(ID: 103)'만 빼달라는 요청이 오면, "102, 103, 104"라는 문자열을 읽어와서 103 부분만 잘라내고 다시 저장해야 함
       * 데이터가 늘어날수록 관리는 매우 어려워짐
     + 원자성 위반 : 데이터베이스의 제 1 정규형, 즉 "테이블의 모든 칸은 원자적인(더 이상 쪼갤 수 없는) 값 하나만 가져야 한다"는 원칙을 위반
   
  - 결론적으로, 두 테이블만으로는 M:N 관계를 표현할 방법이 존재하지 않음 : 첫 번째 문제

3. 문제 2 : 관계에 속한 데이터를 저장할 장소가 없음
   - 두 번째 문제는 M:N 관계가 만들어지는 그 '순간'에만 의미를 갖는 데이터들을 저장할 장소가 없다는 점
   - 주문과 상품 엔티티의 현재 속성 목록(테이블)
<div align="center">
<img src="https://github.com/user-attachments/assets/04fd38c9-fcf0-48ef-a39c-883c3d5d40e4">
</div>

   - '네이트'가 주문 1001로 '무소음 마우스' 1개를 45,000원에 '기계식 키보드'를 2개를 120,000원에 구매했다고 가정
<div align="center">
<img src="https://github.com/user-attachments/assets/2d1326c0-d049-4dee-b688-90d88e5982d8">
</div>

   - 그런데 상품의 가격은 달라질 수 있음 : 기계식 키보드의 가격은 120,000 135,000원으로 변경
   - 기계식 키보드의 주문 수량(2개)과 주문 당시 가격(120,000원) 정보는 어디에 저장해야 할까?
<div align="center">
<img src="https://github.com/user-attachments/assets/f60fc0ee-162a-41aa-8302-76960e92f61e">
</div>

   - 주문 테이블에 주문수량, 주문가격 컬럼을 추가한다고 가정
     + 주문수량에 총 수량 3을 넣으면, 키보드를 몇 개, 마우스를 몇 개 샀는지 알 수 없음
     + 주문가격은 더 심각 : 키보드 가격과 마우스 가격 중 무엇을 넣어야 할까?
     + 총액을 넣자니 이후에 각 상품의 주문 가격을 알 수 없게 됨

   - 상품 테이블에 저장할 수 있을까?
     + 상품 테이블은 현재 상품 정보를 관리하는 곳이지, 과거의 특정 주문 정보를 저장하는 곳이 아님
     + 이 테이블에 주문 수량이나 주문 당시 가격을 추가하는 것은 말이 되지 않음

   - 이처럼 주문 수량과 주문 당시 가격은 주문이나 상품에 속한 속성이 아님
   - 이들은 주문과 상품이 관계를 맺음으로써 발생하는 속성으로, 이런 추가 속성도 누군가는 데이터를 관리해야 함
   - 데이터를 관리하는 역할은 바로 엔티티의 몫

4. 해결책 : 관계를 엔티티로 승격
   - 이 두 가지 문제를 한 번에 해결하는 방법은 M:N 관계를 연관 엔티티(Associative Entity)로 바꾸는 것
   - 연관 엔티티는 두 엔티티의 관계를 나타내는 새로운 엔티티를 만들어, 기존의 M:N 관계를 두 개의 1:N, N:1 관계로 풀어내는 방식
   - 쉽게 이야기해서 관계를 엔티티로 만드는 것
   - 주문과 상품의 M:N 관계를 해소하기 위해 주문 항목(order_item)이라는 새로운 연관 엔티티를 만들기
      + M:N 관계를 두 개의 1:N 관계로 분해하여 문제 1을 해결

   - 다대다 관계 해소 전
<div align="center">
<img src="https://github.com/user-attachments/assets/60c4ab59-5ef8-4f72-82ab-2a5502d31912">
</div>

   - 주문 - 상품 관계(M:N)
      + 하나의 주문 에는 최소 하나 이상의 상품이 포함
      + 하나의 상품은 여러 번 주문될 수도, 아직 한 번도 주문되지 않을 수도 있음

   - 다대다 관계 해소 후
<div align="center">
<img src="https://github.com/user-attachments/assets/381067b0-34bf-4bb8-9d35-090938b22a45">
</div>

   - 주문 항목이라는 연관 엔티티를 만들었음

   - 주문 - 주문 항목 관계 (1:N)
      + 하나의 주문 에는 최소 하나 이상의 주문 항목이 포함
      + 하나의 주문 항목은 특정한 주문 한 건에만 속함

   - 주문 항목 - 상품 관계 (N:1)
      + 하나의 주문 항목 은 반드시 하나의 상품을 가져야 함
      + 하나의 상품은 여러 번 주문될 수도, 아직 한 번도 주문되지 않을 수도 있음

5. 연관 엔티티의 다양한 용어
   - 개념적 모델링 단계의 연관 엔티티(Associative Entity)는 논리/물리적 모델링 단계에서는 연결 테이블(Link Table), 조인 테이블(Join Table), 매핑 테이블(Mapping Table) 등 다양한 이름으로 불림
   - 어떤 용어를 사용하든 이는 다대다 관계를 해소하고 관계에 대한 추가 데이터를 저장하기 위해 두 개 이상의 테이블을 연결하는 중간 테이블을 의미

6. 최종 모델의 테이블 예시
   - 지금은 개념적 모델링 단계이지만 이해를 돕기 위해 다대다 관계를 해소하는 경우 실제 테이블이 이떻게 만들어지는지 간단히 살펴보기 (필드는 최소화)
<div align="center">
<img src="https://github.com/user-attachments/assets/e6863b23-5756-40f4-891b-bcd467828563">
<img src="https://github.com/user-attachments/assets/8296d2fc-1291-41af-b67f-efd8d138f35e">
</div>

   - 결과 분석
   - 문제 1 해결 : 주문_항목 테이블은 주문ID와 상품ID를 각각의 컬럼으로 가짐으로써 M:N 관계를 완벽하게 풀어냄
      + 주문 1001은 주문_항목 테이블의 두 행(201, 202)을 통해 두 개의 상품과 연결
      + 네이트가 주문한 주문 1001 내용으로만 추려서 확인
<div align="center">
<img src="https://github.com/user-attachments/assets/b07a7b8f-870e-4feb-b075-53fade2e9674">
</div>

   - 1001 주문 내용 확인
      + '네이트'는 주문 1001로 '무소음 마우스' 1개를 45,000원에 '기계식 키보드'를 2개를 120,000원에 구매한 것을 확인할 수 있음
      + 상품 테이블의 기계식 키보드 가격은 네이트가 주문한 120,000원 보다 올라서 135,000원으로 변경되었음
      + 네이트는 한 번에 2개의 상품을 주문

   - 문제 2 해결 : 주문_항목 테이블은 주문가격(주문 당시 가격)과 주문수량 속성을 가질 완벽한 공간이 됨
      + 주문 1001의 키보드는 할인 기간이라 120,000원에 2개 구매
      + 주문 1004의 키보드는 할인이 끝나 135,000원에 1개 구매
<div align="center">
<img src="https://github.com/user-attachments/assets/54878b98-b4a3-4c36-89c0-0e20daac19c9">
</div>

   - 이처럼 연관 엔티티를 도입함으로써, 물리적으로 구현이 불가능하고 중요한 데이터를 저장할 수 없었던 M:N 관계의 두 가지 문제를 모두 깔끔하게 해결할 수 있었음

7. 실무 팁 - M:N 관계는 반드시 풀고, 필요한 속성을 찾기
   - 개념적 모델링에서 M:N 관계를 발견했다면, 두 가지를 거의 확신해도 좋음
   - 첫째, 이 관계는 논리적 / 물리적 모델링 단계에서 거의 100% 연관 엔티티(연결 테이블)로 해소
     + M:N 관계를 그대로 두고는 테이블을 설계할 수 없기 때문임

   - 둘째, 실무에서 마주하는 대부분의 M:N 관계는 그 자체로 추가적인 속성을 가짐
     + 예제의 주문 수량, 주문 당시 가격
     + 때로는 '주문 시점에 각 상품에 적용된 할인율' 같은 속성이 더 필요할 수도 있음
     + 특히 실무에서는 테이블에 데이터(행)를 추가한 일시(날짜)와 같은 정보를 기본으로 저장하기 때문에 대부분의 경우 추가적인 속성이 필요

  - 따라서 M:N 관계를 발견하면 "아, 여기에는 연관 엔티티가 필요하겠구나"라고 생각하는 것을 넘어, "이 관계가 만들어지는 순간에만 의미를 갖는 데이터는 무엇일까?"를 적극적으로 질문하고 찾아내야 함
