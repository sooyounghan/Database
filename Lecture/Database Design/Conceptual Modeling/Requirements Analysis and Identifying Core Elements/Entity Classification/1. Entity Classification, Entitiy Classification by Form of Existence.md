-----
### 엔티티 분류
-----
1. 데이터베이스 설계는 '회원', '상품', '주문'과 같은 데이터 덩어리들을 식별하는 것에서 시작
   - 하지만, '회원' 데이터와 '주문' 데이터는 그 성격이 완전히 다름
     + '회원' 데이터는 한 번 가입하면 잘 변하지 않고 꾸준히 유지되지만, '주문' 데이터는 매 순간 새롭게 쌓이는 사건에 가까움
     + 결과적으로 시간이 지남에 따라 회원보다는 주문 데이터가 폭발적으로 증가할 것을 쉽게 예측할 수 있음

   - 이처럼 엔티티(데이터 덩어리)의 성격과 역할을 제대로 파악하고 구분하는 과정이 바로 엔티티 분류
   - 이 분류 과정을 통해 우리는 데이터의 본질을 꿰뚫어 보고, 앞으로 만들 테이블의 구조, 키(Key) 설계, 관계 설정, 그리고 성능 최적화 전략까지 설계의 큰 그림을 그릴 수 있음
   - 마치 건축가가 건물을 짓기 전에 벽돌, 철근, 유리 등 각 자재의 특성을 파악하여 적재적소에 사용하는 것과 같은 이치

2. 개념적 모델링 단계에서 엔티티는 데이터의 성격, 역할, 그리고 다른 데이터와의 관계에 따라 여러 기준으로 분류할 수 있음
   - 이를 통해 데이터 구조를 더 명확하게 이해하고 효율적인 데이터베이스를 설계할 수 있음
   - 엔티티를 분류하는 주요 기준은 존재 형태, 생성 시점 및 역할, 그리고 존재 종속성(독립성)

-----
### 엔티티 분류 - 존재 형태에 따른 분류
-----
1. 존재 형태에 따른 분류 : 유형, 개념, 사건 엔티티
   - 엔티티를 식별하는 가장 직관적인 방법 중 하나는 엔티티가 나타내는 대상의 존재 형태를 기준으로 분류하는 것
   - 엔티티는 크게 유형 엔티티, 개념 엔티티, 사건 엔티티의 세 가지로 분류할 수 있음
   - 유형 엔티티
     + 유형 엔티티는 물리적인 형태를 가지고 있어 눈으로 보거나 만질 수 있는 실체를 표현하는 엔티티
     + 이들은 현실 세계에 구체적으로 존재하는 객체들이므로, 데이터 모델링 과정에서 가장 먼저, 그리고 가장 쉽게 식별되는 경향이 있음
     + 특징
        * 물리적 형태가 존재
        * 업무로부터 식별이 용이
        * 상대적으로 안정적이며 지속적으로 활용되는 정보를 담음
     + 예시  
        * 사원, 학생, 고객, 교수 (사람)
        * 상품, 자재, 물품, 차량, 건물 (사물)
        * 강의실, 창고, 지점 (장소)

   - 개념 엔티티
     + 개념 엔티티는 물리적인 형태는 없지만, 업무적으로 관리해야 할 중요한 개념이나 아이디어를 표현하는 엔티티
     + 이는 눈에 보이지 않기 때문에 유형 엔티티에 비해 식별하기가 다소 까다로울 수 있으며, 비즈니스 프로세스에 대한 깊이 있는 이해를 필요로 함
     + 특징
        * 물리적 형태가 없는 추상적인 개념
        * 업무 규칙이나 제도, 분류 기준 등을 표현
        * 유형 엔티티와 마찬가지로 비교적 안정적인 정보를 관리
     + 예시
        * 부서, 조직, 팀 (조직 구조)
        * 계좌, 보험상품 (금융 상품 및 장부)
        * 과목, 학과 (교육 및 분류 체계)

   - 사건 엔티티 (이벤트 엔티티)
     + 사건 엔티티는 업무 프로세스가 진행됨에 따라 발생하는 특정 행위나 사건을 표현하는 엔티티
     + 이는 특정 시점에 발생하며, 비즈니스 활동의 결과를 기록하는 역할을 함
     + 따라서 사건 엔티티는 시간이 지남에 따라 데이터가 지속적으로 누적되는 특징을 가지며, 각종 통계 및 분석 자료의 핵심 소스가 됨
     + 특징
        * 업무 수행에 따라 발생하는 행위를 기록
        * 시간의 흐름에 따라 인스턴스가 계속해서 발생
        * 발생량이 많고, 각종 통계 자료에 활용될 수 있음
     + 예시 
        * 주문, 계약, 청구, 매출 (판매 및 계약 관련 사건)
        * 결제, 입금, 출금, 미납 (재무 관련 사건)
        * 수강신청, 예약, 취소, 사고접수 (서비스 관련 사건)

2. 실무 예시
   - 이 세 가지 엔티티의 조합은 우리가 만들려는 시스템의 핵심 목적이 무엇인지 알려주는 중요한 힌트가 됨
   - 만약 데이터 모델에 '주문', '결제', '예약' 같은 사건 엔티티가 가득하다면, 그 시스템은 마치 매일매일의 거래를 기록하는 '온라인 거래 장부'와 같음 (쇼핑몰의 실시간 주문 처리 시스템처럼, 계속해서 발생하는 사건들을 빠르고 정확하게 기록하는 것이 주된 임무라는 뜻)
   - 반대로 '고객', '상품', '직원' 같은 유형/개념 엔티티가 설계의 중심이라면, 이는 여러 곳에서 사용될 '기준 정보'나 '고객 명단'을 관리하는 시스템일 가능성이 높음 (이런 시스템의 목표는 거래 기록보다는, 회사의 중요한 자산이 되는 핵심 정보를 정확하고 일관되게 유지하는 것)
   - 결국 엔티티를 어떻게 분류하고 구성하는지 살펴보면, 만들려는 시스템의 최종 목적과 정체성을 엿볼 수 있음 : 이는 마치 건물의 골격을 보면 그 건물이 주택인지, 공장인지 알 수 있는 것과 같음
   - 엔티티 분류가 실무에서 어떤 도움이 되는지 구체적인 예시
     + 쇼핑몰의 회원 이나 상품은 유형 / 개념 엔티티 : 다른 데이터가 존재하기 위한 근간이 됨
     + 반면 주문은 주문이라는 '사건'이 발생할 때마다 생성되는 사건 엔티티(이벤트 엔티티)

   - 실무 관점 : 사건 엔티티는 시간이 지남에 따라 데이터가 폭발적으로 증가할 것을 쉽게 예측할 수 있음
     + 예를 들어, 쇼핑몰에 10만 개의 상품이 있고 100만 명의 회원이 있다면, 상품 테이블은 10만 개, 회원 테이블은 100만 개의 행을 가질 뿐임
     + 하지만 하루에 주문이 10,000건씩만 들어와도 주문 테이블은 1년이면 365만 건, 3년이면 1000만 건이 넘는 데이터가 쌓이게 됨
     + 이렇게 데이터의 성격과 증가 추이를 미리 파악하면, 주문 같은 테이블을 설계할 때부터 다음과 같은 전략을 세울 수 있음
        * 인덱스 전략 : 데이터가 수백만 건이 되면, 특정 회원의 주문 목록을 찾거나(WHERE 회원ID = ?), 특정 날짜의 주문을 조회하는(WHERE 주문 일시 BETWEEN ? AND ?) SELECT 문은 인덱스 없이는 재앙적인 성능 저하를 일으킴
           * 따라서 회원ID 나 주문 일시 같은 조회 조건으로 자주 사용될 컬럼에 인덱스를 생성하는 것은 선택이 아닌 필수
        * 데이터 파티셔닝(Partitioning) 및 아카이빙(Archiving) : 5년 전, 10년 전 주문 데이터까지 하나의 거대한 테이블에 모두 담아두는 것은 매우 비효율적
           * 파티셔닝은 주문 테이블을 주문 일시(예: 연도별, 월별) 기준으로 물리적으로 분리하여 저장하는 기술
           * 이렇게 하면 '최근 한 달 주문 조회'와 같은 쿼리는 훨씬 작은 데이터 영역만 탐색하므로 속도가 비약적으로 향상
           * 아카이빙은 아예 사용 빈도가 극히 낮은 오래된 데이터를 별도의 백업 테이블이나 스토리지로 옮겨서, 현재 운영 중인 테이블의 크기를 작고 빠르게 유지하는 전략





