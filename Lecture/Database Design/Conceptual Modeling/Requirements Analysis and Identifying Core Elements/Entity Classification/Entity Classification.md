-----
### 엔티티 분류
-----
1. 데이터베이스 설계는 '회원', '상품', '주문'과 같은 데이터 덩어리들을 식별하는 것에서 시작
   - 하지만, '회원' 데이터와 '주문' 데이터는 그 성격이 완전히 다름
     + '회원' 데이터는 한 번 가입하면 잘 변하지 않고 꾸준히 유지되지만, '주문' 데이터는 매 순간 새롭게 쌓이는 사건에 가까움
     + 결과적으로 시간이 지남에 따라 회원보다는 주문 데이터가 폭발적으로 증가할 것을 쉽게 예측할 수 있음

   - 이처럼 엔티티(데이터 덩어리)의 성격과 역할을 제대로 파악하고 구분하는 과정이 바로 엔티티 분류
   - 이 분류 과정을 통해 우리는 데이터의 본질을 꿰뚫어 보고, 앞으로 만들 테이블의 구조, 키(Key) 설계, 관계 설정, 그리고 성능 최적화 전략까지 설계의 큰 그림을 그릴 수 있음
   - 마치 건축가가 건물을 짓기 전에 벽돌, 철근, 유리 등 각 자재의 특성을 파악하여 적재적소에 사용하는 것과 같은 이치

2. 개념적 모델링 단계에서 엔티티는 데이터의 성격, 역할, 그리고 다른 데이터와의 관계에 따라 여러 기준으로 분류할 수 있음
   - 이를 통해 데이터 구조를 더 명확하게 이해하고 효율적인 데이터베이스를 설계할 수 있음
   - 엔티티를 분류하는 주요 기준은 존재 형태, 생성 시점 및 역할, 그리고 존재 종속성(독립성)

3. 존재 형태에 따른 분류 : 유형, 개념, 사건 엔티티
   - 엔티티를 식별하는 가장 직관적인 방법 중 하나는 엔티티가 나타내는 대상의 존재 형태를 기준으로 분류하는 것
   - 엔티티는 크게 유형 엔티티, 개념 엔티티, 사건 엔티티의 세 가지로 분류할 수 있음
   - 유형 엔티티
     + 유형 엔티티는 물리적인 형태를 가지고 있어 눈으로 보거나 만질 수 있는 실체를 표현하는 엔티티
     + 이들은 현실 세계에 구체적으로 존재하는 객체들이므로, 데이터 모델링 과정에서 가장 먼저, 그리고 가장 쉽게 식별되는 경향이 있음
     + 특징
        * 물리적 형태가 존재
        * 업무로부터 식별이 용이
        * 상대적으로 안정적이며 지속적으로 활용되는 정보를 담음
     + 예시  
        * 사원, 학생, 고객, 교수 (사람)
        * 상품, 자재, 물품, 차량, 건물 (사물)
        * 강의실, 창고, 지점 (장소)

   - 개념 엔티티
     + 개념 엔티티는 물리적인 형태는 없지만, 업무적으로 관리해야 할 중요한 개념이나 아이디어를 표현하는 엔티티
     + 이는 눈에 보이지 않기 때문에 유형 엔티티에 비해 식별하기가 다소 까다로울 수 있으며, 비즈니스 프로세스에 대한 깊이 있는 이해를 필요로 함
     + 특징
        * 물리적 형태가 없는 추상적인 개념
        * 업무 규칙이나 제도, 분류 기준 등을 표현
        * 유형 엔티티와 마찬가지로 비교적 안정적인 정보를 관리
     + 예시
        * 부서, 조직, 팀 (조직 구조)
        * 계좌, 보험상품 (금융 상품 및 장부)
        * 과목, 학과 (교육 및 분류 체계)

   - 사건 엔티티 (이벤트 엔티티)
     + 사건 엔티티는 업무 프로세스가 진행됨에 따라 발생하는 특정 행위나 사건을 표현하는 엔티티
     + 이는 특정 시점에 발생하며, 비즈니스 활동의 결과를 기록하는 역할을 함
     + 따라서 사건 엔티티는 시간이 지남에 따라 데이터가 지속적으로 누적되는 특징을 가지며, 각종 통계 및 분석 자료의 핵심 소스가 됨
     + 특징
        * 업무 수행에 따라 발생하는 행위를 기록
        * 시간의 흐름에 따라 인스턴스가 계속해서 발생
        * 발생량이 많고, 각종 통계 자료에 활용될 수 있음
     + 예시 
        * 주문, 계약, 청구, 매출 (판매 및 계약 관련 사건)
        * 결제, 입금, 출금, 미납 (재무 관련 사건)
        * 수강신청, 예약, 취소, 사고접수 (서비스 관련 사건)

4. 실무 예시
   - 이 세 가지 엔티티의 조합은 우리가 만들려는 시스템의 핵심 목적이 무엇인지 알려주는 중요한 힌트가 됨
   - 만약 데이터 모델에 '주문', '결제', '예약' 같은 사건 엔티티가 가득하다면, 그 시스템은 마치 매일매일의 거래를 기록하는 '온라인 거래 장부'와 같음 (쇼핑몰의 실시간 주문 처리 시스템처럼, 계속해서 발생하는 사건들을 빠르고 정확하게 기록하는 것이 주된 임무라는 뜻)
   - 반대로 '고객', '상품', '직원' 같은 유형/개념 엔티티가 설계의 중심이라면, 이는 여러 곳에서 사용될 '기준 정보'나 '고객 명단'을 관리하는 시스템일 가능성이 높음 (이런 시스템의 목표는 거래 기록보다는, 회사의 중요한 자산이 되는 핵심 정보를 정확하고 일관되게 유지하는 것)
   - 결국 엔티티를 어떻게 분류하고 구성하는지 살펴보면, 만들려는 시스템의 최종 목적과 정체성을 엿볼 수 있음 : 이는 마치 건물의 골격을 보면 그 건물이 주택인지, 공장인지 알 수 있는 것과 같음
   - 엔티티 분류가 실무에서 어떤 도움이 되는지 구체적인 예시
     + 쇼핑몰의 회원 이나 상품은 유형 / 개념 엔티티 : 다른 데이터가 존재하기 위한 근간이 됨
     + 반면 주문은 주문이라는 '사건'이 발생할 때마다 생성되는 사건 엔티티(이벤트 엔티티)

   - 실무 관점 : 사건 엔티티는 시간이 지남에 따라 데이터가 폭발적으로 증가할 것을 쉽게 예측할 수 있음
     + 예를 들어, 쇼핑몰에 10만 개의 상품이 있고 100만 명의 회원이 있다면, 상품 테이블은 10만 개, 회원 테이블은 100만 개의 행을 가질 뿐임
     + 하지만 하루에 주문이 10,000건씩만 들어와도 주문 테이블은 1년이면 365만 건, 3년이면 1000만 건이 넘는 데이터가 쌓이게 됨
     + 이렇게 데이터의 성격과 증가 추이를 미리 파악하면, 주문 같은 테이블을 설계할 때부터 다음과 같은 전략을 세울 수 있음
        * 인덱스 전략 : 데이터가 수백만 건이 되면, 특정 회원의 주문 목록을 찾거나(WHERE 회원ID = ?), 특정 날짜의 주문을 조회하는(WHERE 주문 일시 BETWEEN ? AND ?) SELECT 문은 인덱스 없이는 재앙적인 성능 저하를 일으킴
           * 따라서 회원ID 나 주문 일시 같은 조회 조건으로 자주 사용될 컬럼에 인덱스를 생성하는 것은 선택이 아닌 필수
        * 데이터 파티셔닝(Partitioning) 및 아카이빙(Archiving) : 5년 전, 10년 전 주문 데이터까지 하나의 거대한 테이블에 모두 담아두는 것은 매우 비효율적
           * 파티셔닝은 주문 테이블을 주문 일시(예: 연도별, 월별) 기준으로 물리적으로 분리하여 저장하는 기술
           * 이렇게 하면 '최근 한 달 주문 조회'와 같은 쿼리는 훨씬 작은 데이터 영역만 탐색하므로 속도가 비약적으로 향상
           * 아카이빙은 아예 사용 빈도가 극히 낮은 오래된 데이터를 별도의 백업 테이블이나 스토리지로 옮겨서, 현재 운영 중인 테이블의 크기를 작고 빠르게 유지하는 전략

5. 역할 및 발생 시점에 따른 분류 : 기본, 중심, 행위 엔티티
   - 엔티티는 비즈니스 프로세스 내에서 수행하는 역할과 데이터가 생성되는 시점에 따라 계층적으로 분류할 수 있DMA
   - 이 분류법은 데이터의 발생 순서와 의존성을 명확히 하여 모델의 논리적 흐름을 체계화
   - 일반적으로 기본 엔티티, 중심엔티티, 행위 엔티티로 구분
   - 기본 엔티티 (Fundamental / Key Entity)
     + 기본 엔티티는 업무에 원래부터 존재하는 정보로서, 다른 엔티티에 의해 생성되지 않고 독립적으로 존재할 수 있는 핵심적인 엔티티
     + '키 엔티티(Key Entity)'라고도 불리며, 일반적으로 다른 엔티티의 부모 역할을 수행
     + 기본 엔티티는 다른 엔티티로부터 주식별자를 상속받지 않고 자신만의 고유한 주식별자를 가진다는 특징이 있음
     + 특징
        * 독립적으로 생성이 가능
        * 주로 다른 엔티티의 부모 역할을 함
        * 자신만의 고유한 주식별자를 가짐
     + 예시 : 회원, 상품, 사원, 부서, 고객, 자재
       
   - 중심 엔티티 (Main / Center Entity)
     + 중심 엔티티는 기본 엔티티로부터 파생되어 생성되며, 해당 업무에서 중심적인 역할을 수행하는 엔티티
     + 이들은 독립적으로 존재하기보다는 기본 엔티티 간의 관계에서 발생하는 핵심적인 비즈니스 트랜잭션을 나타내는 경우가 많음
     + 따라서 데이터 발생량이 많고, 다른 엔티티와의 관계를 통해 수많은 행위 엔티티를 생성하는 허브 역할을 함
     + 특징
        * 기본 엔티티로부터 발생
        * 업무 프로세스의 중심적인 역할을 담당
        * 데이터 발생량이 많고, 많은 행위 엔티티를 파생시킴
     + 예시 : 주문, 계약, 청구, 매출
       
   - 행위 엔티티 (Action/Behavioral Entity)
     + 행위 엔티티는 두 개 이상의 부모 엔티티(주로 기본 엔티티와 중심 엔티티)로부터 발생하며, 업무가 흘러가면서 생성되는 상세 정보를 기록하는 엔티티
     + 이들은 내용이 자주 변경되거나 데이터양이 지속적으로 증가하는 특징을 가짐
     + 모델 내에서 데이터양이 가장 많은 엔티티가 되는 경우가 많음
     + 특징
       * 두 개 이상의 부모 엔티티로부터 발생
       * 데이터 내용이 자주 변경되거나 데이터양이 빠르게 증가
       * 상세 설계 단계에서 도출되는 경우가 많음
     + 예시 : 주문 이력, 신청변경이력, 결제 내역, 로그, 주문 항목

6. 실무 예시
   - 이 세 가지 분류는 '기본 → 중심 → 행위'로 업무가 흘러가는 순서와 데이터의 '원인과 결과'를 명확하게 보여준줌
   - 쉽게 비유를 하자면 이것은 마치 한 편의 이야기를 만드는 것과 같음
     + 이야기는 주인공인 '고객'과 '상품'(기본 엔티티)이 등장하면서 시작
     + 이 두 주인공이 만나 '주문'(중심 엔티티)이라는 핵심 사건을 만듬
     + 그리고 이 '주문'이라는 사건으로 인해 '주문 이력(행위 엔티티)'이나 '결제 내역'(행위 엔티티) 같은 구체적인 행동들이 뒤따라 기록

   - 이런 분류가 실제 개발할 때 어떤 도움이 되는가?
     + 모델의 이해도와 커뮤니케이션 비용 감소
        * 프로젝트는 혼자 하는 것이 아닌, 기획자, 개발자, DBA 등 다양한 직무의 사람들이 협업
        * 이때 '회원'은 기본 엔티티, '주문'은 중심 엔티티, '주문 상품'은 행위 엔티티'라고 정의하면, 모두가 데이터의 위계와 흐름을 동일한 관점에서 이해할 수 있음
        * "이번 기능은 주문(중심) 로직에 변경이 있고, 그에 따라 결제 이력(행위) 데이터가 추가로 쌓여야 한다"라고 말하는 것 처럼 명확하고 효율적인 소통이 가능해짐
     + 체계적인 개발 순서와 일정 관리
        * 엔티티 분류는 그대로 개발의 우선순위가 됨
        * 당연히 독립적으로 존재하는 기본 엔티티(회원 , 상품) 관련 기능부터 개발해야 하며, 그다음, 이들을 기반으로 동작하는 중심 엔티티(주문) 기능을, 마지막으로 상세 내역인 행위 엔티티(주문 이력, 결제 내역) 기능을 구현하는 것이 자연스러운 순서
        * 이렇게 하면 의존성 문제없이 안정적으로 시스템을 구축할 수 있음
        * 프로젝트 관리자(PM) 입장에서는 이를 기준으로 업무 순서를 정할 수 있음
     + 성능과 데이터 관리 전략 수립의 기준
        * 엔티티의 특성은 곧 데이터의 특성을 의미
        * 기본 엔티티(회원 , 상품) : 데이터 변경이 잦지 않고, 주로 조회(READ) 작업이 많으므로, 따라서 조회 성능에 최적화된 인덱싱 전략이 중요
        * 중심 엔티티(주문): 조회의 중심축이자 트랜잭션의 핵심으로, 데이터는 꾸준히 증가하며, 조회(SELECT)뿐만 아니라 주문 상태 변경(UPDATE)도 빈번하게 일어남
          * 따라서 다양한 검색 조건에 대한 인덱스 전략이 매우 중요
          * 예를 들어, 주문 테이블은 사용자가 '내 주문 목록'을 볼 때(회원ID 기준), 관리자가 '오늘의 주문'을 확인할 때(주문 일시 기준), '배송 준비 중'인 주문을 찾을 때(주문상태 기준) 등 여러 방식으로 조회
          * 따라서 회원ID, 주문 일시, 주문상태 같은 컬럼에는 각각의 쓰임새에 맞는 인덱스를 생성하는 것이 성능 유지의 관건
        * 행위 엔티티(주문 이력 , 결제 내역): 하나의 주문을 할 때 결제 방식을 신용카드, 포인트, 쿠폰 3가지를 사용해서 결제했다고 가정
          * 그러면 주문 (중심 엔티티)은 하나의 행이 만들어지지만, 결제 내역 (행위 엔티티)은 3개의 행이 만들어짐
          * 따라서 데이터가 폭발적으로 증가(Heavy INSERT)하며, 가장 많은 저장 공간을 차지하게 될 테이블
          * 따라서 설계 초기부터 데이터 파티셔닝(Partitioning)이나 주기적인 아카이빙(Archiving) 전략을 고민해야 함
          * 이런 테이블을 주문일 기준으로 월별 또는 분기별로 분할해두면, 특정 기간의 데이터 조회나 삭제 시 성능 저하를 막을 수 있음
          * 이런 고민 없이 테이블을 하나로만 운영하면, 몇 년 뒤 데이터가 수억 건 쌓였을 때 시스템 전체가 느려지는 재앙을 맞게 됨
          * 물론 중심 엔티티 데이터가 많다면 이런 고민이 함께 필요함

   - 엔티티를 역할과 시점에 따라 분류하는 것은 단순히 이론적인 활동이 아님
   - 복잡한 비즈니스를 명확한 데이터 구조로 풀어내고, 프로젝트를 안정적으로 이끌어가기 위한 실무 데이터베이스 설계의 첫걸음이라 할 수 있음

7. 실무 이야기 : 분류 용어를 외우기보다 본질을 이해하는 것
   - 실무에서 동료 개발자나 DBA와 회의하면서 "이건 중심 엔티티니까..." 라거나 "저 테이블은 사건 엔티티의 특징을 가지므로..." 와 같은 학술적인 용어는 거의 사용하지 않음
   - 그렇다면 왜 엔티티를 분류하는 방법을 배우는 것일까?
     + 이 분류법은 데이터베이스를 설계하는 '사고의 틀(Framework)'을 제공
     + 용어 자체를 암기해서 사용하는 것이 목적이 아니라, 각 테이블이 가지는 데이터의 '본질'과 '성격'을 빠르고 정확하게 간파하는 훈련을 하는 것
     + 숙련된 개발자는 이런 용어를 사용하지 않아도, 테이블 설계를 보면 본능적으로 그 성격을 파악하고 그에 맞는 전략을 구사
     +  우리가 이 개념을 배우는 것은, 바로 그 '본능적인' 전문가의 사고방식을 체계적으로 따라가기 위함

   - 정리하자면, 엔티티 분류는 실무에서 사용하는 '용어'라기보다는, 복잡한 요구 사항 속에서 데이터의 구조와 성격을 꿰뚫어 보고, 미래에 발생할 문제를 예측하며, 최적의 해결책을 찾아가는 과정에서 머릿속에 그려지는 '설계 지도'와 같음
   - 이 지도를 그리는 훈련을 통해 우리는 더 견고한 데이터베이스 시스템을 만들 수 있는 것

8. 강한 엔티티와 약한 엔티티
   - 엔티티는 다른 엔티티와의 관계 속에서 자신의 존재 여부가 결정되는지에 따라 강한 엔티티와 약한 엔티티로 분류할 수 있음
   - 강한 엔티티 (Strong Entity) : 강한 엔티티는 다른 어떤 엔티티의 존재 여부와 관계없이 독립적으로 존재할 수 있는 엔티티를 의미
     + 즉, 자신의 존재를 위해 다른 엔티티에 의존하지 않음
     + 강한 엔티티는 자신을 유일하게 식별할 수 있는 고유한 속성 또는 속성들의 집합, 즉 기본 키(Primary Key)를 가지고 있음
     + 특징
        * 독립적인 존재가 가능
        * 자신만의 고유한 주식별자를 가짐
        * 다른 엔티티의 존재에 의존하지 않음
     + 예시 : 사원, 고객, 상품, 부서 등과 같이 독립적으로 관리될 수 있는 대부분의 엔티티

   - 약한 엔티티 (Weak Entity) : 약한 엔티티는 다른 엔티티(이를 '소유 엔티티' 또는 '식별 엔티티'라 부르는 강한 엔티티)가 존재하지 않으면 독립적으로 존재할 수 없는, 존재 종속적인 엔티티
     + 특징 : 약한 엔티티는 소유 엔티티가 있어야만 자신의 존재가 의미를 가짐
     + 식별자 구성 : 전통적인 방식에서 약한 엔티티는 자신을 식별하기 위해 소유 엔티티의 주식별자를 빌려와 자신의 속성(부분키)과 결합하여 주식별자로 삼음
        * 예를 들어 부모의 기본 키(employee_id)를 가져와 자식의 속성(name)과 합쳐 복합 기본 키(Composite Primary Key) (employee_id, name)를 만듬
     + 예시
        * 부양가족 : '부양가족' 정보는 특정 '사원'에게 소속될 때만 의미가 있음
        * 어떤 사원에도 속하지 않은 '홍길동(자녀)'이라는 데이터는 존재할 수 없음
        * 즉, 부양가족은 사원 없이는 존재 의미가 없음

9. 실무 예시
   - 왜 강한 엔티티와 약한 엔티티를 구분해야 하는가?
   - 회사 인사 시스템 데이터베이스에 '네이트(자식)'라는 부양가족 정보는 있는데, 이 사람이 대체 누구의 부양가족인지 알 수 없다면 어떻게 되는가?
   - 이 부양가족에게 연말정산 혜택을 적용해야 하는가? 누구의 연말정산에? 가족수당을 지급해야 한다면, 어느 사원에게 지급해야 하는가?
   - 비상 연락망에 이 가족의 정보를 포함해야 하는가? 누구의 비상 연락망에?
   - 이처럼 부모 엔티티(사원) 정보가 없는 자식 데이터(부양가족), 즉 '고아 데이터(Orphaned Data)'가 생겨나면 데이터베이스의 정합성(Integrity)이 깨지고, 인사 관리 시스템 전체가 신뢰를 잃게 됨
     + 급여, 복지, 세금 등 모든 핵심 기능에 심각한 오류를 초래할 수 있음
   - 약한 엔티티는 저장할 때 부모의 식별자를 반드시 함께 포함해서 저장해야 함
   - 따라서 부모가 존재하지 않는 문제를 설계 단계에서 부터 원천 차단할 수 있음  
   - 강한 엔티티와 약한 엔티티의 구분은 바로 이런 데이터 재앙을 설계 단계에서부터 원천적으로 차단하기 위해 존재
   - 엔티티의 독립성을 기준으로 강한 엔티티와 약한 엔티티를 구분하는 것은 테이블의 키와 외래 키 제약조건을 설계하는데 중요한 역할을 함

10. 실무 이야기 - 식별 관계, 비식별 관계
    - 전통적인 설계 방식에서 약한 엔티티는 소유 엔티티의 주식별자를 빌려와 자신의 속성(부분키)과 결합해서 복합 기본 키를 만드는 방식을 사용 : 이것을 논리적 모델링 단계에서 식별 관계라 함
      + 이렇게 되면 자식을 만들 때 반드시 부모의 PK 값을 입력해야 함
      + 결과적으로 논리적 제약 조건이 테이블의 기본 키 구조에 그대로 반영되어, 누가 봐도 관계를 명확하게 이해할 수 있고 데이터 무결성을 PK 레벨에서 보장
      + 즉, 부모 없는 자식이 존재할 가능성을 원천 차단
    - 이것이 바로 데이터 모델링의 원칙을 가장 충실하게 따른 '전통적'이고 '교과서적인' 방법
    - 하지만 이런 전통적인 방식은 최근에는 잘 사용하지 않고, 대신에 더 유연하고 실용적인 비식별 관계라는 방법을 주로 사용

11. 구조적 관계 표현을 위한 특수 엔티티
    - 엔티티 간의 관계가 단순한 연결선을 넘어, 그 자체가 하나의 독립된 의미를 갖는 개념일 때가 있음
    - 이러한 사건(Event)이나 분류(Classification)와 같은 복잡한 관계를 효과적으로 모델에 반영하기 위해 사용하는 것이 바로 연관 엔티티와 슈퍼타입/서브타입 구조
    - 연관 엔티티 (Associative Entity)
      + 연관 엔티티는 두 개 이상의 엔티티 간에 발생하는 특정 사건, 행위, 계약 등을 표현하기 위해 도출되는 엔티티
      + 즉, 관계(Relationship) 자체가 중요한 속성을 가져 하나의 독립된 실체(Entity)로 다뤄져야 할 때 사용
      + 개념적 본질 : 연관 엔티티의 가장 중요한 존재 이유는 '관계'에 종속되는 속성을 저장하기 위함
        * 예를 들어, '학생'과 '과목'의 관계에서는 '성적'이나 '수강신청일' 같은 데이터가 발생
        * 이 데이터는 '학생'의 것도, '과목'의 것도 아닌, '수강'이라는 행위 자체에 속함
        * 이 '수강'을 표현하는 것이 바로 연관 엔티티
      + 구조적 의미 : 연관 엔티티는 두 개 이상의 다른 엔티티 간에 존재하는 다대다(M:N) 관계를 해소
        * 관계형 데이터베이스는 다대다 관계를 직접 구현할 수 없기 때문에, 이 중간 엔티티를 통해 하나의 다대다 관계를 일대다(1:N), 다대일(N:1) 관계로 변환
    - 슈퍼타입 / 서브타입 엔티티 (Supertype / Subtype Entity)
      + 슈퍼타입 / 서브타입 모델은 논리적으로 동일한 개념 그룹에 속하지만 일부 속성이나 관계에서 차이가 있는 엔티티들을 효과적으로 표현하기 위한 기법
      + 이는 'IS-A' 관계(예: '관리자는 사원의 한 종류이다')를 모델링하며, 객체지향 프로그래밍의 상속(Inheritance) 개념과 매우 유사
      + 슈퍼타입 (Supertype) : 그룹 내 모든 엔티티(서브타입)들이 공통적으로 가지는 속성과 관계를 정의하는 상위 엔티티
      + 서브타입 (Subtype) : 슈퍼타입으로부터 공통 속성을 상속받고, 자신만의 고유한 속성이나 관계를 추가로 가지는 하위 엔티티
      + 예시 : '사원' 엔티티를 슈퍼타입으로, '정규직 사원'과 '계약직 사원'을 서브타입으로 모델링할 수 있음

   - 엔티티 분류는 설계자가 다양한 관점에서 데이터의 본질을 이해하는데 도움을 줌줌
