-----
### 엔티티 분류 - 역할 및 발생 시점에 따른 분류
-----
1. 역할 및 발생 시점에 따른 분류 : 기본, 중심, 행위 엔티티
   - 엔티티는 비즈니스 프로세스 내에서 수행하는 역할과 데이터가 생성되는 시점에 따라 계층적으로 분류할 수 있DMA
   - 이 분류법은 데이터의 발생 순서와 의존성을 명확히 하여 모델의 논리적 흐름을 체계화
   - 일반적으로 기본 엔티티, 중심엔티티, 행위 엔티티로 구분
   - 기본 엔티티 (Fundamental / Key Entity)
     + 기본 엔티티는 업무에 원래부터 존재하는 정보로서, 다른 엔티티에 의해 생성되지 않고 독립적으로 존재할 수 있는 핵심적인 엔티티
     + '키 엔티티(Key Entity)'라고도 불리며, 일반적으로 다른 엔티티의 부모 역할을 수행
     + 기본 엔티티는 다른 엔티티로부터 주식별자를 상속받지 않고 자신만의 고유한 주식별자를 가진다는 특징이 있음
     + 특징
        * 독립적으로 생성이 가능
        * 주로 다른 엔티티의 부모 역할을 함
        * 자신만의 고유한 주식별자를 가짐
     + 예시 : 회원, 상품, 사원, 부서, 고객, 자재
       
   - 중심 엔티티 (Main / Center Entity)
     + 중심 엔티티는 기본 엔티티로부터 파생되어 생성되며, 해당 업무에서 중심적인 역할을 수행하는 엔티티
     + 이들은 독립적으로 존재하기보다는 기본 엔티티 간의 관계에서 발생하는 핵심적인 비즈니스 트랜잭션을 나타내는 경우가 많음
     + 따라서 데이터 발생량이 많고, 다른 엔티티와의 관계를 통해 수많은 행위 엔티티를 생성하는 허브 역할을 함
     + 특징
        * 기본 엔티티로부터 발생
        * 업무 프로세스의 중심적인 역할을 담당
        * 데이터 발생량이 많고, 많은 행위 엔티티를 파생시킴
     + 예시 : 주문, 계약, 청구, 매출
       
   - 행위 엔티티 (Action/Behavioral Entity)
     + 행위 엔티티는 두 개 이상의 부모 엔티티(주로 기본 엔티티와 중심 엔티티)로부터 발생하며, 업무가 흘러가면서 생성되는 상세 정보를 기록하는 엔티티
     + 이들은 내용이 자주 변경되거나 데이터양이 지속적으로 증가하는 특징을 가짐
     + 모델 내에서 데이터양이 가장 많은 엔티티가 되는 경우가 많음
     + 특징
       * 두 개 이상의 부모 엔티티로부터 발생
       * 데이터 내용이 자주 변경되거나 데이터양이 빠르게 증가
       * 상세 설계 단계에서 도출되는 경우가 많음
     + 예시 : 주문 이력, 신청변경이력, 결제 내역, 로그, 주문 항목

2. 실무 예시
   - 이 세 가지 분류는 '기본 → 중심 → 행위'로 업무가 흘러가는 순서와 데이터의 '원인과 결과'를 명확하게 보여준줌
   - 쉽게 비유를 하자면 이것은 마치 한 편의 이야기를 만드는 것과 같음
     + 이야기는 주인공인 '고객'과 '상품'(기본 엔티티)이 등장하면서 시작
     + 이 두 주인공이 만나 '주문'(중심 엔티티)이라는 핵심 사건을 만듬
     + 그리고 이 '주문'이라는 사건으로 인해 '주문 이력(행위 엔티티)'이나 '결제 내역'(행위 엔티티) 같은 구체적인 행동들이 뒤따라 기록

   - 이런 분류가 실제 개발할 때 어떤 도움이 되는가?
     + 모델의 이해도와 커뮤니케이션 비용 감소
        * 프로젝트는 혼자 하는 것이 아닌, 기획자, 개발자, DBA 등 다양한 직무의 사람들이 협업
        * 이때 '회원'은 기본 엔티티, '주문'은 중심 엔티티, '주문 상품'은 행위 엔티티'라고 정의하면, 모두가 데이터의 위계와 흐름을 동일한 관점에서 이해할 수 있음
        * "이번 기능은 주문(중심) 로직에 변경이 있고, 그에 따라 결제 이력(행위) 데이터가 추가로 쌓여야 한다"라고 말하는 것 처럼 명확하고 효율적인 소통이 가능해짐
     + 체계적인 개발 순서와 일정 관리
        * 엔티티 분류는 그대로 개발의 우선순위가 됨
        * 당연히 독립적으로 존재하는 기본 엔티티(회원 , 상품) 관련 기능부터 개발해야 하며, 그다음, 이들을 기반으로 동작하는 중심 엔티티(주문) 기능을, 마지막으로 상세 내역인 행위 엔티티(주문 이력, 결제 내역) 기능을 구현하는 것이 자연스러운 순서
        * 이렇게 하면 의존성 문제없이 안정적으로 시스템을 구축할 수 있음
        * 프로젝트 관리자(PM) 입장에서는 이를 기준으로 업무 순서를 정할 수 있음
     + 성능과 데이터 관리 전략 수립의 기준
        * 엔티티의 특성은 곧 데이터의 특성을 의미
        * 기본 엔티티(회원 , 상품) : 데이터 변경이 잦지 않고, 주로 조회(READ) 작업이 많으므로, 따라서 조회 성능에 최적화된 인덱싱 전략이 중요
        * 중심 엔티티(주문): 조회의 중심축이자 트랜잭션의 핵심으로, 데이터는 꾸준히 증가하며, 조회(SELECT)뿐만 아니라 주문 상태 변경(UPDATE)도 빈번하게 일어남
          * 따라서 다양한 검색 조건에 대한 인덱스 전략이 매우 중요
          * 예를 들어, 주문 테이블은 사용자가 '내 주문 목록'을 볼 때(회원ID 기준), 관리자가 '오늘의 주문'을 확인할 때(주문 일시 기준), '배송 준비 중'인 주문을 찾을 때(주문상태 기준) 등 여러 방식으로 조회
          * 따라서 회원ID, 주문 일시, 주문상태 같은 컬럼에는 각각의 쓰임새에 맞는 인덱스를 생성하는 것이 성능 유지의 관건
        * 행위 엔티티(주문 이력 , 결제 내역): 하나의 주문을 할 때 결제 방식을 신용카드, 포인트, 쿠폰 3가지를 사용해서 결제했다고 가정
          * 그러면 주문 (중심 엔티티)은 하나의 행이 만들어지지만, 결제 내역 (행위 엔티티)은 3개의 행이 만들어짐
          * 따라서 데이터가 폭발적으로 증가(Heavy INSERT)하며, 가장 많은 저장 공간을 차지하게 될 테이블
          * 따라서 설계 초기부터 데이터 파티셔닝(Partitioning)이나 주기적인 아카이빙(Archiving) 전략을 고민해야 함
          * 이런 테이블을 주문일 기준으로 월별 또는 분기별로 분할해두면, 특정 기간의 데이터 조회나 삭제 시 성능 저하를 막을 수 있음
          * 이런 고민 없이 테이블을 하나로만 운영하면, 몇 년 뒤 데이터가 수억 건 쌓였을 때 시스템 전체가 느려지는 재앙을 맞게 됨
          * 물론 중심 엔티티 데이터가 많다면 이런 고민이 함께 필요함

   - 엔티티를 역할과 시점에 따라 분류하는 것은 단순히 이론적인 활동이 아님
   - 복잡한 비즈니스를 명확한 데이터 구조로 풀어내고, 프로젝트를 안정적으로 이끌어가기 위한 실무 데이터베이스 설계의 첫걸음이라 할 수 있음

3. 실무 이야기 : 분류 용어를 외우기보다 본질을 이해하는 것
   - 실무에서 동료 개발자나 DBA와 회의하면서 "이건 중심 엔티티니까..." 라거나 "저 테이블은 사건 엔티티의 특징을 가지므로..." 와 같은 학술적인 용어는 거의 사용하지 않음
   - 그렇다면 왜 엔티티를 분류하는 방법을 배우는 것일까?
     + 이 분류법은 데이터베이스를 설계하는 '사고의 틀(Framework)'을 제공
     + 용어 자체를 암기해서 사용하는 것이 목적이 아니라, 각 테이블이 가지는 데이터의 '본질'과 '성격'을 빠르고 정확하게 간파하는 훈련을 하는 것
     + 숙련된 개발자는 이런 용어를 사용하지 않아도, 테이블 설계를 보면 본능적으로 그 성격을 파악하고 그에 맞는 전략을 구사
     +  우리가 이 개념을 배우는 것은, 바로 그 '본능적인' 전문가의 사고방식을 체계적으로 따라가기 위함

   - 정리하자면, 엔티티 분류는 실무에서 사용하는 '용어'라기보다는, 복잡한 요구 사항 속에서 데이터의 구조와 성격을 꿰뚫어 보고, 미래에 발생할 문제를 예측하며, 최적의 해결책을 찾아가는 과정에서 머릿속에 그려지는 '설계 지도'와 같음
   - 이 지도를 그리는 훈련을 통해 우리는 더 견고한 데이터베이스 시스템을 만들 수 있는 것
