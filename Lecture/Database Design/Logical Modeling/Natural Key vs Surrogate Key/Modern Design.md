-----
### 현대적인 설계
-----
1. 현대적인 데이터베이스 설계에서는 자연 키와 대리 키 중에 어떤 것을 기본 키로 선택해야 할까?
   - 결론부터 말하면, 거의 모든 경우에 대리 키 사용을 강력하게 권장
   - 자연 키는 비즈니스 로직과 데이터의 '신원(ID)'을 강하게 결합시킴 : 이는 앞서 본 예시처럼 비즈니스 로직이 변경될 때, 데이터베이스의 근간을 흔들 수 있는 심각한 위험을 내포
   - 반면, 대리 키는 데이터의 신원(ID)을 비즈니스 로직으로부터 완전히 분리시킴
   - 덕분에 비즈니스 요구사항이 아무리 자유롭게 바뀌어도 데이터 모델의 안정성은 흔들리지 않음
   - member_id는 그대로이므로, 이 회원을 참조하는 orders, qna, review 테이블은 아무런 영향을 받지 않음 : 이것이 바로 느슨한 결합(Loose Coupling)의 힘
   - 이러한 유연성과 안정성 때문에 현대적인 애플리케이션 설계 환경에서는 대리 키를 기본 전략으로 선택

2. 과거 : 데이터 중심의 시대와 자연 키
   - 과거의 데이터베이스 설계는 애플리케이션보다 데이터 그 자체의 독립성에 더 큰 중점을 두었음
   - 데이터베이스가 시스템의 중심이었고, 여러 다른 애플리케이션을 이 중앙 데이터베이스에 직접 연결하여 데이터를 사용하는 경우가 많았음
   - 이런 환경에서는 데이터 자체만으로 의미를 가지는 자연 키가 매우 합리적인 선택
      + 직관성 : 주민등록번호 , 학번 , 이메일 과 같은 자연 키는 그 값만 봐도 어떤 데이터인지 바로 알 수 있었음
        * DB 관리자(DBA)가 SQL 클라이언트로 직접 데이터를 조회하고 관리하는 일이 많았기 때문에 이런 직관성은 큰 장점

      + 저장 공간 효율성 : 지금이야 저장 공간 비용이 매우 저렴해졌지만, 과거에는 디스크 비용이 비쌌음
        * 자연 키를 사용하면 별도의 ID 컬럼을 추가할 필요가 없으므로, 아주 약간이라도 저장 공간을 아낄 수 있었음

      + '데이터 모델링 순수주의' : 데이터 모델링 관점에서, 엔티티(Entity)는 고유하게 식별 가능한 속성(Attribute)을 가져야 한다는 원칙
        * 이 원칙에 따라 비즈니스적으로 의미 있는 식별자(자연 키)를 기본 키로 삼는 것이 '올바른' 설계라고 여겨졌음
        * 과거 데이터 중심 설계의 중요한 원칙은 "현실 세계의 데이터를 가장 논리적이고 자연스럽게 표현하는 것"
        * 이를 위해 모델러들은 각 테이블(엔티티)의 자연스러운 식별자, 자연 키(Natural Key)를 찾는 데 많은 노력을 기울였음
        * 그리고 과거에는 비즈니스 로직의 변경 속도가 지금처럼 빠르지 않았음 : 한번 정해진 주민등록번호 나 학번 같은 식별자는 거의 바뀌지 않을 것이라는 믿음이 있었음
        * 따라서 자연 키의 '불변성'에 대한 가정이 어느 정도는 통용될 수 있었음

   - 레거시 프로젝트 : 한번 설계된 데이터베이스는 아주 오랜기간 유지되며, 특히 오래된 레거시 프로젝트들은 자연 키를 사용하는 경우가 많음

3. 현대 : 애플리케이션 중심의 시대와 대리 키
   - 하지만 인터넷이 보편화되고 애플리케이션의 복잡성이 기하급수적으로 증가하면서 상황은 완전히 달라짐
   - 이제 시스템의 중심은 데이터베이스가 아닌 애플리케이션으로 이동
   - 비즈니스 요구사항의 폭발적인 변화 속도
     + 스타트업과 애자일(Agile) 개발 방식이 대세가 되면서, '비즈니스 로직은 언제든지 바뀔 수 있다'는 것이 기본 전제
     + 이메일을 PK로 사용했다면, 소셜 로그인 기능을 도입하는 순간 데이터베이스 설계의 근간부터 다시 고민해야 하는 대참사가 발생
     + 하지만 비즈니스와 아무 관련 없는 숫자 ID, 즉 대리 키를 사용하면, 이메일 정책이 어떻게 바뀌든, member_id는 영원히 그 자리에 그대로 있음
     + 애플리케이션의 비즈니스 로직만 수정하면 될 뿐, 데이터 모델은 전혀 영향을 받지 않음
     + 이처럼 현대의 데이터베이스 설계는 변경에 유연하게 대처하는 능력(Flexibility)이 매우 중요

   - ORM 기술의 등장과 패러다임 전환
      + JPA(Java Persistence API), Hibernate, Entity Framework 같은 ORM(Object-Relational Mapping) 기술의 등장도 대리 키 사용을 가속화
      + ORM은 '애플리케이션의 객체'와 '관계형 데이터베이스의 테이블' 사이의 불일치를 해소하고 자동으로 연결해주는 기술
      + 개발자가 SQL을 직접 작성하지 않아도 객체를 통해 데이터베이스 작업을 할 수 있도록 도움
      + 개발자는 자바나 C# 같은 객체 지향 언어로 비즈니스 로직을 만들지만, 객체 지향 언어로 개발을 하더라도 데이터는 결국 관계형 데이터베이스에 저장해야 함
      + 따라서 관계형 데이터베이스의 테이블 구조에 맞춰 SQL을 작성해야함
      + 이 두 가지 방식은 근본적으로 다르기 때문에, 개발자는 항상 '객체 세계'와 '데이터베이스 세계' 사이에서 객체를 SQL로 변경하고, 또 SQL의 결과를 객체로 변경하는 지루한 번역 작업을 계속해야만 했음
      + ORM은 바로 이 귀찮고 반복적인 번역 작업을 대신 처리해주는 기술

   - ORM 이전 : 개발자가 모든 SQL을 직접 다루던 시대
     + ORM이라는 통역사가 없던 시절, 개발자는 모든 SQL을 직접 작성해야 했음
     + 애플리케이션에서 member 객체를 다루기 위해, 개발자는 회원 저장소 와 같은 클래스를 만들고 그 안에 CRUD(생성,조회, 수정, 삭제) 기능을 위한 SQL을 하나하나 직접 작성해야 했음
     + 예) 예를 들어, 다음과 같은 member 객체가 있다고 가정
```java
class Member {
   private Long memberId;
   private String loginId;
   private String password;
   private String name;
   private String email;
   private DateTime created_at;
   // ...
}
```  
   - 이 객체를 DB에 저장하고 관리하는 코드
   - 회원 저장 (Create)
```java
public Member save(Member member) {
    String sql = "INSERT INTO member(login_id, password, name, email, address, created_at) VALUES (?, ?, ?, ?, ?, NOW())";  
    // 코드를 통해 sql을 실행
    return member;
 }
```
   - 회원 조회 (Read)
```java
public Member findById(Long memberId) {
    String sql = "SELECT member_id, login_id, name, email, address, created_at " + "FROM member WHERE member_id = ?";
    // 코드를 통해 sql을 실행
    return new Member(...);
}
```
   - 회원 수정 (Update)
```java
public void update(Member member) {
    String sql = "UPDATE member SET name = ?, email = ?, address = ? " + "WHERE member_id = ?";
    // 코드를 통해 sql을 실행
}
```
   - 회원 삭제 (Delete)
```java
public void delete(Member member) {
    String sql = "DELETE FROM member WHERE member_id = ?";
    // 코드를 통해 sql을 실행
 }
```
   - 결과적으로 이 member 객체를 데이터베이스에 저장(INSERT)하거나, 특정 회원의 이름을 변경(UPDATE)하려면, 개발자는 다음과 같은 수 많은 SQL 구문을 직접 만들어서 애플리케이션 코드에 추가해야 헸음
     + 회원 저장 (Create) : INSERT INTO member(login_id, ...) VALUES(?, ...)
     + 회원 조회 (Read) : SELECT member_id, ... FROM member WHERE member_id = ?
     + 회원 수정 (Update) : UPDATE member SET name = ?, ... WHERE member_id = ?
     + 회원 삭제 (Delete) : DELETE FROM member WHERE member_id = ?
   - 객체의 필드가 10개라면, INSERT 문에 10개의 컬럼과 10개의 물음표를, SELECT 문에 10개의 컬럼을 나열해야 함
   - 만약 객체에 필드 하나가 추가되거나 변경되면 이 모든 SQL을 다시 찾아서 수정해야 하는 끔찍한 일이 발생

   - ORM의 등장 : 똑똑한 통역사가 알아서 처리하는 시대
     + JPA와 같은 ORM 기술을 사용하면, 개발자는 더 이상 단순한 CRUD를 위해 SQL을 직접 작성하지 않음
     + 그저 객체를 ORM에게 넘겨주기만 하면, ORM이 해당 객체에 맞는 최적의 SQL을 대신 생성해서 데이터베이스와 통신
```java
// JPA 통역사를 사용하는 가상 코드

// 회원 저장
public void save(Member member) {
   // "이 객체 저장해 줘" 라고 말하면 끝. INSERT SQL을 자동 생성해서 실행
   jpa.persist(member);
}

// 회원 삭제
public void delete(Member member) {
   jpa.remove(member); // 이 한 줄이면 DELETE SQL이 자동으로 생성 및 실행
}

// 회원 조회
public member findById(Long memberId) {
   // "member 타입으로, ID가 memberId인 객체 찾기
   // SELECT SQL을 자동 생성해서 실행
   return jpa.find(Member.class, memberId);
}

// 회원 이름 수정
public void updateName(Long memberId, String newName) {
    Member member = jpa.find(Member.class, memberId); // 먼저 객체를 찾기
    member.setName(newName); // 객체의 이름만 바꾸면 완료. UPDATE SQL을 자동 생성해서 실행
}
```
   - 코드를 보면 이전에 작성한 SQL이 모두 사라진 것을 알 수 있음
   - 그리고 여기서는 JPA라는 ORM 기술이 이런 SQL을 대신 작성하고 실행 : 따라서, 이전과 비교해 개발 생산성이 비약적으로 증가
   - UPDATE : update 라는 명령조차 없지만, 그저 회원을 찾아서 객체의 이름만 바꿨을 뿐
     + 객체의 값을 바꾸면, 나중에 데이터베이스에도 반영할 것을 기억해둠
     + 그리고 모든 작업이 끝나는 시점에 자동으로 UPDATE SQL을 만들어서 실행

4. ORM과 대리 키
   - PK(기본 키) : ORM은 자기가 관리해야 할 회원들의 '관리 명단'을 가지고 있음
     + 그리고 이 명단에서 각 회원을 구분하는 유일한 값으로 바로 PK를 사용
   - 한 가지 중요한 전제 조건이 필요 : 절대 변하지 않는 고유 식별자
   - 여기 도서관이 하나 있다고 가정
      + 도서관 : 데이터베이스
      + 사서 : ORM (JPA)
      + 책 : 객체 (BOOK 객체)
      + 도서관리번호 : 대리 키 (book_id)
      + 책 제목 : 자연 키 (book_name)

   - 사서(ORM)는 모든 책(객체)에 고유하고 절대 변하지 않는 '도서관리번호'(book_id)를 붙여서 관리
   - 덕분에 책의 제목(book_name)이 바뀌거나, 책에 낙서를 해도 사서는 도서관리번호만으로 어떤 책인지 정확하게 알 수 있음
     + 즉, 이를 쉽게 인지하고 수정(UPDATE)
   - 그런데 만약 '책 제목'(book_name)을 도서관리번호처럼 사용한다면, 즉, book_name 인 자연 키를 PK로 사용한 경우
     + 어떤 사람이 'JPA 프로그래밍' 이란 책을 빌려갔는데, 책의 제목을 '스프링 프로그래밍'으로 수정하고 반납
     + 이때 사서(ORM)는 대혼란에 빠짐 : 결국 책의 신원(ID) 자체가 바뀌어버렸기 때문에 사서는 이 책을 추적할 수 없게 됨
   - 이것이 바로 ORM이 대리 키를 압도적으로 선호하는 이유
      + 대리 키는 비즈니스와 무관하게 절대 변하지 않는 '관리 번호' 역할을 함
      + 객체를 안정적으로 추적하고 관리할 수 있게 해줌
      + 반면, 언제든 바뀔 수 있는 비즈니스 속성인 자연 키는 ORM을 혼란에 빠뜨릴 수 있음
      + 이러한 이유로 JPA와 같은 ORM 기술은 변경 불가능한(Immutable) 대리 키 사용을 강력하게 권장

   - 현대 애플리케이션 개발은 ORM을 통해 생산성을 극대화
     + 그리고 ORM의 성능과 안정성을 100% 활용하기 위한 최고의 파트너가 바로 대리 키
     + 이 둘의 조합은 개발자가 SQL이라는 번거로운 번역 작업에서 벗어나 비즈니스 로직 구현에만 집중할 수 있도록 해주는 핵심 기능

5. 분산 시스템과 마이크로서비스 아키텍처(MSA)
   - 최근에는 하나의 거대한 애플리케이션을 여러 개의 작은 서비스로 나누는 마이크로서비스 아키텍처가 널리 쓰이고 있음
   - '회원 서비스', '주문 서비스', '상품 서비스'가 각각 독립된 데이터베이스를 가질 수 있음
   - 이런 환경에서 email 같은 자연 키를 여러 서비스에 걸쳐 일관되게 사용하고 관리하는 것은 거의 재앙에 가까움
     + '회원 서비스'에서 이메일 정책이 바뀌면, '주문 서비스'를 비롯한 다른 모든 서비스도 그 변경에 영향을 받기 때문임

   - 하지만 각 서비스가 외부에는 member_id라는 절대 변하지 않는 안정적인 대리 키 값으로만 소통 할 경우
     + '회원 서비스' 내부에서 이메일이든, 전화번호든, 어떤 것으로 회원을 식별하든 다른 서비스는 전혀 신경 쓸 필요가 없음
     + 오직 member_id 값만 알면 됨 : 이는 서비스 간의 결합도(Coupling)를 낮추어 시스템 전체의 안정성과 확장성을 크게 높여줌

6. 결론 : 현대적 설계의 핵심은 '느슨한 결합'
   - 정리하자면, 과거의 설계가 데이터의 의미와 직관성을 중시했다면, 현대의 설계는 비즈니스 변화에 대한 유연성과 시스템의 안정성을 최우선으로 고려
   - 대리 키는 비즈니스 로직이라는 변화무쌍한 세계로부터 데이터의 '신원(ID)'이라는 가장 중요한 본질을 지켜주는 완벽한 안전장치 역할
   - 이 안전장치 덕분에 우리는 비즈니스 로직은 비즈니스 로직대로, 데이터는 데이터대로 각자의 역할에 충실하며 안정적으로 성장하는 시스템을 만들 수 있음
   - 이것이 바로 현대적인 설계가 '느슨한 결합(Loose Coupling)'을 추구하며 대리 키를 압도적으로 선호하는 이유
   - 실무에서는 고민의 여지 없이 대리 키를 사용하는 것이 정답에 가까움

7. 대리 키-PK, 자연 키-UNIQUE : 현대적인 데이터베이스 설계는 대리 키-PK, 자연 키-UNIQUE 방식이 사실상 표준
