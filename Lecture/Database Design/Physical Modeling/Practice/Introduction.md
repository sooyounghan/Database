-----
### 물리적 모델링 - 실습 시작
-----
1. 쇼핑몰 논리적 모델을 실제 MySQL 데이터베이스에서 동작하는 물리적 스키마로 변환하는 최종 실습
   - 우리가 직접 DDL(CREATE TABLE)을 작성하여 살아 숨 쉬는 데이터베이스를 만드는 과정

2. 논리적 모델링 확인 : 물리적 모델링을 시작하기 전에 앞서 진행한 논리적 모델링 확인
<div align="center">
<img src="https://github.com/user-attachments/assets/7cb2d66a-014e-4491-97d9-14e4df3f4603">
</div>

3. 논리적 모델링
   - 개념적 모델을 바탕으로 데이터의 논리적 구조와 관계를 정의하는 논리적 모델링을 완성
   - 대리 키와 비식별 관계를 사용하는 현대적인 설계 원칙에 따라, 정규화된 아주 깔끔한 모델을 생성
   - 논리적 모델을 우리가 사용하기로 한 MySQL이라는 특정 데이터베이스에 맞게 변환하고, 성능과 효율성, 그리고 현실적인 제약 조건들을 고려하여 최적화하는 물리적 모델링을 진행할 차례

4. 물리적 모델링
   - 물리적 모델링은 각 테이블별로 어떤 데이터 타입을 선택하고, 어떤 제약조건과 인덱스를 추가해야 할지 신중하게 결정하며 CREATE TABLE 구문을 완성해 나감
   - 물리적 모델링의 결과는 크게 테이블 정의서와 실제 테이블을 만들 수 있는 스크립트인 DDL이 나와야 함
   - 물리적 모델링의 핵심 목표 중 하나는 바로 '성능'
     + 논리적으로 아무리 완벽한 모델이라도, 실제 서비스에서 쿼리가 느리다면 아무 소용이 없음
     + 조회 성능을 극대화하기 위해 의도적으로 정규화 원칙을 위배하는 역정규화(Denormalization) 기법과 데이터 검색 속도를 획기적으로 높이는 인덱스(Index) 설계를 쇼핑몰 모델에 직접 적용

5. 물리적 모델링 순서
   - 테이블과 컬럼 변환 : 논리적 모델의 엔티티는 테이블로, 속성은 컬럼으로 변환
     + 이때 테이블명, 컬럼명을 정하는 규칙(Naming Convention)을 정하고 적용
   - 데이터 타입 정의 : 각 컬럼에 가장 적합한 데이터 타입(예) VARCHAR, INT, DATETIME)을 선택한
     + 이는 저장 공간과 성능에 직접적인 영향을 미침
   - 제약 조건 설정 : 기본 키, 외래 키, NOT NULL 등 데이터의 무결성을 보장하기 위한 제약 조건을 구체적으로 설정
   - 인덱스 설계 : 데이터 조회 성능을 극대화하기 위해 어떤 컬럼에 인덱스를 생성할지 결정
   - 역정규화 및 성능 튜닝 : 필요에 따라 정규화 원칙을 위배하여 테이블을 통합하거나 중복 데이터를 추가하는 '역정규화'를 수행하여 성능을 개선 (최후의 수단)
   - 파티셔닝 샤딩등 기타 기법 적용 : 대용량 테이블의 경우, 특정 기준으로 데이터를 분할하여 저장하는 파티셔닝 같은 고급 기법을 고려
   - 뷰, 저장 프로시저, 함수, 트리거 생성 : 완성된 테이블 구조 위에서 필요한 뷰, 프로시저, 트리거 등 추가적인 데이터베이스 객체를 생성

   - 여기서 위 세단계는 앞서 물리적 모델링에서 설명한 내용대로 진행하면 되며, 여기서는 인덱스 설계와 역정규화 및 성능 튜닝에 집중

6. 용어 사전 활용 : 테이블과 컬럼을 변환할 때는 용어 사전을 적극 활용
7. 뷰, 저장프로시저, 함수, 트리거 : 뷰, 저장프로시저, 함수, 트리거는 여기서 사용하지 않음
