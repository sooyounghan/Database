-----
### 쇼핑몰 테이블 정의서
-----
1. 테이블 정의서
   - 기본값을 비고에 포함 : 기본값은 별도의 항목으로 설명하는 것이 좋음
   - NULL을 제약(제약 조건)에 포함 : NULL은 별도의 항목으로 설명하는 것이 좋음
   - 지면상 NOT NULL은 표현하지 않음 (기본은 NOT NULL로 보면 됨)
   - AUTO_INCREMENT 기본값은 생략
   - created_at, updated_at의 기본값은 생략
   - Unique → UQ
2. 한글명을 영문명으로 변환할 때 앞서 준비한 용어 사전을 사용

3. member
<div align="center">
<img src="https://github.com/user-attachments/assets/242de218-4240-40d5-a7e9-57672b841fc1">
</div>

4. product
<div align="center">
<img src="https://github.com/user-attachments/assets/180919c3-c78b-4ccd-828f-8b2cc7529090">
</div>

5. orders
<div align="center">
<img src="https://github.com/user-attachments/assets/376cb2d1-c05b-4cd5-bcbc-554f5912bdb7">
</div>

6. order_item
<div align="center">
<img src="https://github.com/user-attachments/assets/50212969-3e08-4dba-abc5-b4c4cb5f7323">
</div>

7. delivery
<div align="center">
<img src="https://github.com/user-attachments/assets/a887bbdb-9a4d-4813-9816-9206a4acab06">
</div>

8. pay
<div align="center">
<img src="https://github.com/user-attachments/assets/c9ad5820-21eb-4866-888c-6776d502ea3e">
</div>

9. 생성일과 수정일
   - 실무에서는 모든 테이블에 생성일(created_at)과 수정일(updated_at) 컬럼을 넣는 것이 거의 표준처럼 여겨짐
   - 이 두 컬럼은 데이터가 언제 생성되고 마지막으로 수정되었는지 기록하는, 아주 중요한 '감사(Audit)' 정보를 담고 있음
      + created_at : 데이터가 처음 생성된 시점을 기록하며, 이 값은 한 번 정해지면 절대 변하지 않음
      + updated_at : 데이터가 마지막으로 수정된 시점을 기록하며, 행의 어떤 컬럼이라도 변경되면 이 필드의 값은 현재 시간으로 자동 업데이트
   - 이 정보가 있으면 데이터 관련 문제가 발생했을 때 변경 이력을 추적하여 원인을 파악하기가 매우 용이해짐
     + 예를 들어, "어떤 회원의 주소가 어젯밤에 이상하게 바뀌었다."라는 문의가 들어왔을 때, updated_at을 보면 언제 변경이 일어났는지 즉시 알 수 있고, 해당 시간대의 로그를 집중적으로 분석하여 원인을 찾을 수 있음

   - MySQL의 자동 업데이트 기능을 사용

10. 실무 팁 - 등록자(created_by), 수정자(updated_by)
     - 실무에서는 등록일(created_at), 수정일(updated_at)은 물론이고, 등록자(created_by), 수정자(updated_by)도 추가해서 관리하는 것이 좋음
     - 이렇게 하면 문제가 발생했을 때 관리자가 이 데이터를 수정했는지, 아니면 사용자가 이 데이터를 수정했는지 명확하게 인지할 수 있음
     - 등록자, 수정자는 데이터베이스에서 자동화할 수는 없고, 대신에 애플리케이션에서 관리해야 함
     - 스프링 데이터 JPA와 같은 기술은 애플리케이션에서 이런 부분을 자동화해서 관리할 수 있음

11. 주문일시는 왜 따로 있는가? ( created_at vs. ordered_at )
     - orders 테이블 정의서를 보면 created_at(생성일)과 ordered_at(주문일시)이라는, 언뜻 보기에 비슷해 보이는 두 개의 시간 관련 컬럼이 존재
        + "데이터가 생성된 시간이 주문 시간 아닌가?"라고 생각하기 쉬움
        + 하지만 실무에서는 이 둘을 명확히 구분하는 것이 매우 중요
     - created_at은 시스템의 시간이고, ordered_at은 비즈니스의 시간을 나타냄
     - 시스템의 시간과 비즈니스의 시간
        + created_at (시스템의 시간)
          * 이 컬럼은 데이터베이스에 실제 INSERT 쿼리가 실행되어 행(Row)이 생성된 시점을 기록
          * 순수하게 기술적인 정보로, 데이터가 언제 물리적으로 저장되었는지를 나타내며, 주로 시스템 감사(Audit), 로그 추적, 데이터 백업 및 복구 시점 확인 등 시스템 관리 목적으로 사용
          * 이 값은 데이터베이스가 DEFAULT CURRENT_TIMESTAMP 와 같은 기능을 통해 자동으로 채우도록 설정하는 것이 일반적

        + ordered_at (비즈니스의 시간)
          * 이 컬럼은 비즈니스 이벤트가 발생한 시점, 즉 고객이 우리 쇼핑몰에서 '주문하기' 버튼을 누른 바로 그 순간을 기록
          * 이것은 고객에게 보여주고, 비즈니스 로직을 처리하는 데 사용되는 매우 중요한 정보
          * 예를 들어 "오후 3시 이전 주문 건은 당일 배송"과 같은 정책은 바로 이 ordered_at을 기준으로 판단해야 함
          * 이 값은 사용자의 요청을 받은 백엔드 애플리케이션이 생성하여 데이터베이스에 전달해야 함

12. 두 시간이 달라지는 실무 시나리오
    - 대부분의 경우에는 그 차이가 밀리초(ms) 단위로 매우 작을 것
    - 하지만 시스템의 안정성과 데이터의 정확성을 보장해야 하는 실무에서는 두 시간이 의미 있게 달라지는 경우가 분명히 존재
    - 시나리오 1 : 시스템 장애 또는 지연
        + 가장 흔한 경우로, 사용자가 많아 서버에 부하가 걸리거나, 데이터베이스에 일시적인 성능 저하가 발생했다고 가정
        + 고객 A가 14:59:59 에 '주문하기' 버튼을 클릭 (비즈니스 이벤트 발생)
        + 백엔드 애플리케이션은 이 요청을 받고, 현재 시간 14:59:59를 ordered_at 값으로 확정
        + 애플리케이션이 주문 데이터를 orders 테이블에 INSERT 하려고 시도
        + 하지만 데이터베이스에 부하가 몰려있어 쿼리가 즉시 실행되지 못하고 2초간 대기
        + INSERT 쿼리가 15:00:01 에 최종적으로 실행되어 데이터가 저장
        + 이 경우, 테이블에는 다음과 같이 기록
          * ordered_at : 2025-08-27 14:59:59
          * created_at : 2025-08-27 15:00:01
        + 만약 created_at만 있었다면 이 주문은 '오후 3시 이후 주문'으로 잘못 처리되어 당일 배송에서 누락되었을 것
        + ordered_at을 별도로 관리했기 때문에 우리는 고객의 주문 시점을 정확히 기록하고 비즈니스 규칙을 올바르게 적용할 수 있음

    - 시나리오 2 : 데이터 마이그레이션
        + 기존에 운영하던 쇼핑몰의 데이터를 새로운 시스템으로 이전하는 상황을 가정 : 작년(2024년)의 주문 데이터를 옮겨야 함
        + 2024년 12월 25일에 발생했던 주문 데이터를 새로운 orders 테이블에 INSERT
        + 이때, ordered_at값은 당연히 원래 주문이 발생했던 2024-12-25 10:30:00 으로 지정해서 넣어야 함
        + 하지만 created_at값은 이 데이터가 새로운 시스템에 생성된 시점인 2025-08-27 18:00:00 (마이그레이션 작업 시간)으로 기록될 것
        + 이처럼 과거 데이터를 이전하거나 복원할 때, 비즈니스 발생 시점과 데이터 생성 시점은 완전히 달라짐
        + 두 컬럼을 분리하지 않으면 과거 데이터의 중요한 시간 정보를 잃게 됨

    - 이처럼 created_at과 같은 시스템 컬럼은 기술적인 무결성을 위해, ordered_at 과 같은 비즈니스 컬럼은 비즈니스 로직의 정확성을 위해 반드시 분리하여 관리
    - pay 테이블의 결제 일시(paid_at)도 비즈니스 시간
      + 결제가 최종 완료된 시점을 의미하는데, 여기서는 은행, 신용카드 사에서 결제된 시간을 의미
      + 이 시간을 확인해야 결제에 문제가 발생했을 때 은행, 카드사와 정확한 시간을 맞추어 확인할 수 있음
