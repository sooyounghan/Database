-----
### 테이블과 컬럼 변환 규칙 - 축약어와 단수 복수
-----
1. 축약어 사용의 역사와 함정
   - 과거의 데이터베이스 시스템은 이름 길이에 8자, 16자 같은 엄격한 제약이 있었음 : 이 때문에 축약어 사용이 불가피했지만, 현대의 데이터베이스 시스템에서는 이런 제약이 거의 사라졌음
   - 또한, 과거에는 지금처럼 강력한 자동 완성(Auto-completion) 기능을 갖춘 IDE나 SQL 클라이언트가 드물었음
   - 그럼에도 불구하고 타이핑을 줄여준다는 단기적인 편리함 때문에 축약어를 사용하고 싶은 유혹에 빠지기 쉬움
   - 하지만 의미가 불분명한 축약어는 시간이 지나면서 그 의미를 파악하기 어렵게 만들어 결국 유지보수 비용을 증가시키는 '기술 부채(Technical Debt)'로 쌓이게 됨

2. 좋은 축약어의 조건
   - 물론 모든 축약어가 나쁜 것은 아님
   - 좋은 축약어는 오히려 가독성을 높이고, 널리 사용되어 의미 파악에 전혀 문제가 없음
   - 좋은 축약어의 조건
     + 보편성 (Universality) : id(identifier), avg(average), max(maximum), min(minimum), qty(quantity)처럼 누가 봐도 그 의미를 알 수 있는, 업계에서 널리 통용되는 축약어여야 함
     + 비모호성 (Unambiguity) : 반드시 하나의 의미로만 해석되어야 함 (예를 들어 desc 라는 컬럼 이름은 'description'(설명)과 SQL 예약어인 'descending'(내림차순)으로 모두 해석될 수 있어 혼란을 야기)
        * auth 역시 'author'(저자), 'authentication'(인증), 'authorization'(권한 부여) 등 다양한 의미를 가질 수 있어 피해야 함
     + 일관성 및 문서화 (Consistency & Documentation) : 만약 특정 비즈니스 도메인에서만 통용되는 축약어를 사용해야 한다면, 반드시 프로젝트의 '데이터 사전'이나 '용어집'에 그 의미를 명확히 기록해야 함
       * 그리고 프로젝트의 모든 데이터베이스에서 일관되게 사용해야 함
       * 금융권 - pnl (profit and loss)
       * 쇼핑몰 - sku (Stock Keeping Unit)

3. 나쁜 축약어가 초래하는 장기적 비용
   - 나쁜 축약어는 당장의 편리함보다 훨씬 큰 비용을 장기적으로 발생시킴
   - 유지보수 비용 증가 : 데이터베이스를 처음 접하는 개발자는 축약어의 의미를 파악하기 위해 추가적인 시간을 소모해야 함
     + mem_reg_dt가 member_registration_date의 줄임말임을 추측하는 과정은 불필요한 인지 부하를 유발하고 생산성을 떨어뜨림
     + 물론 mem, reg, dt 를 팀에서 합의한 축약어라면 사용할 수 있음
   - 버그 발생 가능성 증가 : 축약어를 오해하면 잘못된 쿼리를 작성하여 심각한 버그로 이어질 수 있음
     + auth_status가 'authorization'(권한 부여) 상태인지, 'authentication'(인증) 상태인지 불분명하다면 보안 관련 로직에 치명적인 결함을 만들 수 있음
   - 핵심 원칙 : "의심스러우면, 축약하지 말고 전부 써라" - 잘 지은 컬럼 이름은 그 자체로 훌륭한 문서의 역할을 함

4. 균형을 찾는 가이드라인
  - 물론 실무에서는 명확성과 편의성 사이의 균형점을 찾는 지혜가 필요
    + 컬럼 이름이 last_successful_login_attempt_from_mobile_device_timestamp 처럼 지나치게 길어지면 오히려 쿼리 작성과 가독성을 해칠 수 있음

   - 핵심 원칙 : '모호함(Ambiguity)을 제거하는 것'으로, 이 원칙을 지키면서 이름을 적절히 줄일 수 있는 몇 가지 실무 가이드를 제시
   - 테이블 이름으로 컨텍스트를 파악할 수 있다면 과감히 생략
     + 가장 흔하고 효과적인 방법으로 컬럼은 독립적으로 존재하지 않고, 항상 테이블이라는 소속(컨텍스트)이 존재
     + 나쁜 예시) member 테이블 안에 member_name, member_email, member_address라는 컬럼을 만드는 것
     + 좋은 예시) member 테이블 안에서는 그냥 name, email, address라고 지으면 됨
     + SELECT name, email FROM member 쿼리 : 이 name과 email이 member의 정보라는 것을 누구나 알 수 있음
       * member_ 라는 접두사는 불필요하게 이름만 길게 만드는 군더더기
       * 단, 이때 너무 많은 테이블에서 같은 이름을 사용한다면 접두사 사용을 고려
       * 예) member, product 등등 수 많은 테이블에서 name이라는 이름을 사용하면, member_name, product_name 등으로 접두사 고려
       * 예) email : member 테이블을 포함한 몇 개의 테이블만 사용하면, email 그대로 사용
       * 예) status : orders, product, pay, delivery 등 수 많은 테이블에서 상태를 나타내기 위해 사용 - order_status , product_status 등 접두사 고려
     + 핵심은 기본적으로 테이블 명이라는 문맥을 활용하되, 너무 많은 테이블에서 사용해서 조인 시 자주 충돌이 일어나고, 구분이 어렵다면 접두사 사용을 고려

   - 보편적인 약어는 적극적으로 활용
     + 앞서 '좋은 축약어의 조건'에서 이야기했듯이, 모두가 아는 약어는 쓰는 것이 좋음
       * identification → id
       * quantity → qty
       * average → avg
       * number → no (예) post_no )
       * datetime → dt (단, _at 과 같은 접미사 규칙과 충돌하지 않도록 팀 내 합의가 필요)
     + 예를 들어 product_average_rating_point는 product_avg_rating 정도로 충분히 의미를 전달하면서 길이를 줄일 수 있음

   - 이름이 너무 길다면, 모델링이 잘못된 것은 아닌지 의심할 것
     + 때로는 긴 컬럼 이름 자체가 설계의 문제점을 알려주는 신호(Code Smell)일 수 있음
     + 예를 들어, member 테이블에 primary_shipping_address_street_and_postal_code라는 컬럼이 존재한다고 가정 : 이름이 매우 길고 복잡
      * 이것은 '주소'라는 개념을 별도의 컬럼이나 테이블로 분리하지 않았기 때문에 발생하는 문제
      * 이 컬럼을 만드는 대신, address 테이블을 새로 만들고 street, postal_code, is_primary 같은 컬럼으로 분리하는 것이 올바른 정규화 설계
      * 즉, 긴 이름의 문제를 이름 자체를 줄여서 해결하는 것이 아니라 구조적인 개선으로 해결해야 하는 경우
  
   - 위에서 제시한 방법들을 통해 '모호하지 않은 선에서 가장 간결한 이름'을 찾는 연습을 해야 함
   - 중요한 것은 타이핑 몇 번을 줄이는 편의성이 아니라, 추후에 이 컬럼을 봤을 때 단 1초의 망설임도 없이 의미를 파악하게 만드는 것

5. 테이블 이름 : 단수(Singular) vs 복수(Plural)
   - 복수형 주장 (members, products, orders ) : 테이블은 여러 개의 데이터(레코드)가 모여있는 '집합'이므로, 그 의미를 살려 복수형을 써야 한다는 주장
     + SELECT * FROM members 처럼 SQL 쿼리가 좀 더 자연스럽게 읽히는 장점이 존재

   - 단수형 주장 (member, product, order) : 테이블은 해당 엔티티(개체)의 '설계도' 또는 '틀'을 정의하는 것이므로, 엔티티의 이름 그대로 단수형을 써야 한다는 주장
     + member 테이블의 한 행(row)이 한 명의 회원을 의미하므로, 이쪽이 개념적으로 더 명확하다고 볼 수 있음
     + 특히 ORM(Object-Relational Mapping) 기술과 함께 사용할 때 클래스 이름과 매핑하기 용이

   - 결론적으로 어떤 것을 선택하든 정답은 없음
     +하 지만 프로젝트 내에서는 반드시 하나를 선택해서 일관성을 지켜야 함
     + 앞서 만든 DDL에서는 member, product, orders (order는 예약어라 orders로 사용)와 같이 단수형을 기반으로 이름을 생성

6. 한국에서 단수형을 주로 사용하는 이유
   - 한국 개발 환경에서는 언어적 특성과 개발의 편의성이라는 실용적인 이유로 단수형 테이블 이름을 압도적으로 선호
   - 그 이유는 다음과 같음
     + 언어적 특성 : 한국어는 명사의 단수와 복수를 엄격하게 구분하지 않음
       * '사용자'라는 단어는 한 명의 사용자를 지칭할 수도 있고, 여러 명의 사용자를 의미할 수도 있음
       * 따라서 영어처럼 'User'와 'Users'를 구분해야 할 필요성을 크게 느끼지 못하며, 더 간결하고 기본적인 형태인 단수형을 자연스럽게 선호
     + 영문법의 부담 감소 : 영어가 모국어가 아닌 입장에서 불규칙한 복수형(예) Person → People, Analysis → Analyses)을 매번 정확히 사용하는 것은 번거롭고 실수의 여지가 있음
       * 단수형으로 통일하면 이러한 문법적 고민 없이 단순하게 일관된 규칙을 유지할 수 있어 개발 효율성이 높아짐

7. 데이터베이스 입문편과 기본편에서 복수형을 사용한 이유
   - order와 같은 일부 단어는 데이터베이스에서 사용하는 예약어와 충돌 : 예약어와 충돌하는 단어를 테이블 이름으로 사용하려면 매번 백틱(`)을 추가해야 하는 번거로움이 있음
   - 예제 코드를 일관성 있게 유지하기 위해 모든 테이블 이름을 복수형으로 통일 : 만약 order만 orders로 사용하고 다른 테이블은 단수형을 사용했다면, 복수형을 사용한 이유에대해 미리 설명해야 하는 복잡함이 생김

8. 용어 사전 활용
   - 개념적, 논리적 모델링 단계에서는 기획자나 다른 팀원들과의 원활한 소통을 위해 '회원', '주문', '상품'과 같은 한글 용어를 사용하는 경우가 많음
   - 이는 비즈니스 로직을 이해하는 데 매우 효과적
   - 하지만 물리적 모델링으로 넘어오면서 이 한글 이름들은 앞서 설명한 규칙에 따라 반드시 영문으로 변환되어야 한함
   - 이 때 개발자마다 '주문 항목'을 order_detail로 할지, order_item으로 할지 다르게 생각할 수 있음
   - 이러한 불일치를 막아주는 것이 바로 용어 사전
   - 설계 초기에 용어를 표준화해두면, 기획자, 개발자, DBA 등 프로젝트에 참여하는 모든 사람이 동일한 용어를 사용하게 되어 소통의 오류를 줄일 수 있음
   - 또한, 나중에 물리 모델링을 할 때 어떤 영어 단어를 써야 할지 고민하는 시간을 줄여주고, 이름의 비일관성으로 인해 발생하는 버그를 사전에 방지하는 효과 존재
   - 개념적 모델링 단계부터 용어 사전을 정의하면, 용어 사전 덕분에 편리하게 일관성 있게 영문으로 된 물리적 이름을 변환할 수 있음
