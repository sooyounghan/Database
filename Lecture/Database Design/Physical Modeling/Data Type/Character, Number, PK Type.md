-----
### 데이터 타입 - 문자, 숫자, PK 타입
-----
1. 논리적 모델의 '속성'을 물리적 모델의 '컬럼'으로 바꿀 때, 가장 먼저 해야 할 일은 각 컬럼에 어떤 종류의 데이터가 들어갈지 정의하는 것
   - 이것이 바로 데이터 타입을 지정하는 작업
   - 왜 데이터 타입을 신중하게 골라야 할까?
     + 문제 상황 : 쇼핑몰에 '회원' 테이블이 있다고 가정
       * 회원의 나이(age)를 저장해야 하는데, 이 때 어떤 개발자가 '나이는 숫자니까... 그냥 넉넉하게 큰 숫자를 담을 수 있는 타입으로 하자!' 라며 BIGINT 타입을 선택했다고 가정
       * BIGINT 는 약 922경까지 저장할 수 있는 아주 큰 숫자 타입
       * 큰 타입을 쓰는 것이 과연 효율적이지 못함 : 필요 이상의 공간을 차지하고, 데이터를 처리할 때도 더 많은 리소스를 사용하게 되어 결국 성능 저하로 이어짐
     + 이처럼 데이터 타입을 잘못 선택하면 다음과 같은 문제가 발생
       * 저장 공간 낭비 : 필요보다 큰 데이터 타입을 사용하면 디스크 공간이 낭비 (데이터가 수백만, 수천만 건이 되면 이 낭비는 무시할 수 없는 수준이 됨)
       * 성능 저하 : 데이터베이스는 디스크에서 메모리로 데이터를 읽어와 처리하는데, 데이터 타입이 크면 한 번에 읽어올 수 있는 데이터의 양이 줄어들기 때문에, 이는 더 많은 I/O(입출력)를 유발하고, 결국 쿼리 속도를 느리게 만듬
       * 데이터 무결성 훼손 : 데이터의 성격에 맞지 않는 타입을 사용하면 잘못된 데이터가 입력될 수 있음 (예를 들어, 날짜를 문자열(VARCHAR)로 저장하면 '2025-08-21' 뿐만 아니라 '내일', '어제' 같은 엉뚱한 값도 들어갈 수 있음)
     + 따라서 우리는 데이터의 특성과 범위를 정확히 파악하고, 그에 맞는 최적의 데이터 타입을 선택해야 함

2. 문자열 타입
   - 문자열을 저장하는 타입은 크게 가변 길이와 고정 길이로 나뉨
   - VARCHAR(M) : 가변 길이 문자열
     + M은 저장할 수 있는 최대 길이를 의미
     + 실제 저장되는 데이터의 길이에 따라 저장 공간의 크기가 달라짐
     + 예를 들어 VARCHAR(100) 에 'hello' (5글자)를 저장하면, 실제로는 5글자에 해당하는 공간 + 길이 정보(1~2바이트)만 사용 (최대 바이트 길이가 255 이하이면 1바이트, 초과이면 2바이트를 사용)
     + 장점 : 공간 효율이 좋음
     + 단점 : 길이가 변하기 때문에 데이터 수정 시 추가적인 작업이 필요할 수 있음
     + 용도 : 이름, 제목, 주소 등 대부분의 문자열 데이터에 사용
       
   - CHAR(M) : 고정 길이 문자열
     + M은 고정된 길이를 의미
     + CHAR(10) 에 'hello' (5글자)를 저장하면, 나머지 5글자는 공백으로 채워져 무조건 10글자의 공간을 차지
     + 장점 : 길이가 고정되어 있어 데이터 처리 속도가 VARCHAR 보다 약간 빠를 수 있음
     + 단점 : 공간 낭비가 심함
     + 용도 : 주민등록번호, 전화번호, 성별('M' / 'F')처럼 길이가 항상 고정된 데이터에 사용할 수 있음

   - TEXT : 매우 긴 텍스트를 저장할 때 사용
     + 게시물의 본문, 상품의 상세 설명 등에 사용 (TEXT는 약 6만 5바이트, MEDIUMTEXT는 약 1600만 바이트, LONGTEXT는 약 42억 바이트)

   - 실무 가이드 : 일단 VARCHAR 를 쓸 것
     + 대부분의 경우 VARCHAR 가 가장 합리적인 선택
     + 길이가 고정된 데이터라도 그 길이가 바뀔 가능성이 있다면 VARCHAR 를 쓰는 것이 더 안전함
     + VARCHAR의 길이는 얼마나 잡아야 할까? 너무 길게 잡으면 메모리 사용량이 늘어날 수 있고, 너무 짧게 잡으면 데이터가 잘리는 문제가 발생
       * 저장될 데이터의 평균적인 길이와 최대 길이를 고려하여 합리적으로 설정해야 함
       * 예를 들어, 사용자 이름은 50자, 이메일 주소는 100자 정도로 잡는 것이 일반적

   - 예제) 회원 정보를 저장하는 테이블을 생성
```sql
DROP TABLE IF EXISTS member_sample;

CREATE TABLE member_sample (
 member_id BIGINT PRIMARY KEY,
     email VARCHAR(100), -- 이메일 주소는 길이가 다양
     name VARCHAR(50), -- 이름도 길이가 다양
     gender CHAR(1), -- 성별은 'M' 또는 'F'로 길이가 1로 고정
     introduction TEXT -- 자기소개는 매우 길어질 수 있음
);

INSERT INTO member_sample (member_id, email, name, gender, introduction)
VALUES (1, 'test@example.com', '션', 'M', '안녕하세요. 데이터베이스를 배우는 션입니다.');
```

   - 💡 심화 : VARCHAR 길이는 왜 메모리 사용량에 영향을 줄까?
     + VARCHAR는 가변 길이인데 왜 길이를 크게 잡으면 메모리 사용량이 늘어날까? 디스크 저장 공간과 메모리 사용은 다른 이야기이기 때문임
     + 결론부터 말하면, MySQL이 쿼리를 처리하기 위해 메모리에 임시 공간을 할당할 때 VARCHAR 에 설정된 최대 길이를 기준으로 삼는 경우가 많음
     + 예를 들어, 우리가 ORDER BY 나 GROUP BY 같은 정렬이나 그룹화 작업을 수행한다고 생각
       * MySQL은 효율적인 작업을 위해 디스크에 있는 데이터를 메모리로 가져와서 중간 결과물을 저장할 임시 테이블(temporary table)을 만들 수 있음
       * 이때, 메모리에 만들어지는 임시 테이블의 컬럼 크기는 원본 테이블의 VARCHAR 최대 길이를 따라감
       * name VARCHAR(50) 컬럼을 정렬 : MySQL은 메모리에 한 사람의 이름을 저장하기 위해 최대 50글자를 담을 수 있는 공간을 할당하고, 실제 이름이 'Kim' (3글자)이더라도, 정렬 중 자리가 바뀔 수 있으므로 넉넉하게 최대 크기로 잡는 것
       * name VARCHAR(4000) 컬럼을 정렬: MySQL은 같은 원리로 메모리에 최대 4000글자를 담을 수 있는 공간을 할당
     + 이제 수백만 건의 회원 데이터를 정렬 : VARCHAR(50) 일 때와 VARCHAR(4000) 일 때, 정렬 작업을 위해 필요한 총 메모리의 양은 어마어마한 차이가 남
       * 만약 할당해야 할 메모리가 너무 커서 서버의 물리적인 메모리(RAM) 용량을 초과하면, MySQL은 디스크를 임시 공간으로 사용하기 시작
       * 디스크 I/O는 메모리 I/O보다 수천 배에서 수만 배 느리기 때문에, 이는 곧바로 쿼리 성능의 급격한 저하로 이어짐

      + 따라서 VARCHAR 의 길이를 설정할 때는 "혹시 모르니 그냥 엄청 크게 잡자"가 아니라, "이 데이터가 가질 수 있는 합리적인 최대 길이가 얼마일까?"를 신중하게 고민해야 함
      + 이것이 바로 디스크 공간 효율뿐만 아니라, 시스템 전체의 성능을 생각하는 좋은 데이터베이스 설계자의 자세

3. 숫자 타입 : 숫자 데이터는 정수형과 소수형으로 나뉨
   - 정수 타입 : 정수를 저장할 때 사용하며, 저장할 수 있는 값의 범위에 따라 여러 타입으로 나뉨
<div align="center">
<img src="https://github.com/user-attachments/assets/6791c76d-db83-42d9-a7fc-d4f98a81809d">
</div>

   - 실무 가이드
      + TINYINT 는 상태 값(예) 0=대기, 1=처리중, 2=완료)이나 한정된 범위의 숫자에 사용하면 공간을 매우 효율적으로 쓸 수 있음
      + 일반적인 게시물 ID, 회원 ID 등은 INT로 충분한 경우가 많음
        * 하지만 양수만 저장하는 경우 UNSIGNED 옵션을 사용하면 저장 범위를 2배로 늘릴 수 있음
        * 예를 들어 INT UNSIGNED는 0부터 약 42억까지 저장할 수 있어, 음수가 필요 없는 ID 값에 사용하기 좋음

      + 앞으로 서비스가 엄청나게 커질 것을 대비해 무조건 BIGINT를 사용하는 경우가 있는데, 이는 신중해야 함
        * 트래픽이 많지 않은 관리자 페이지의 ID 등은 INT로도 충분
        * 하지만 사용자의 주문 ID처럼 데이터가 폭발적으로 증가할 것이 확실하다면 처음부터 BIGINT를 고려하는 것이 좋음
        * 나중에 INT 에서 BIGINT 로 바꾸는 작업은 매우 고통스럽기 때문임

   - 소수 타입 : 소수점이 있는 숫자를 저장할 때 사용
      + DECIMAL(M, D) : 고정 소수점 타입. 금융 계산처럼 정확한 소수점 계산이 필요할 때 반드시 사용
        * M은 총 자릿수, D는 소수점 이하 자릿수를 의미
        * 예를 들어 DECIMAL(10, 2)는 정수 부분 8자리, 소수 부분 2자리까지 총 10자리의 숫자를 정확하게 저장할 수 있음

      + DOUBLE 또는 FLOAT : 부동 소수점 타입. 과학 계산이나 근사치가 허용되는 빠른 계산에 사용
        * 하지만 소수점 계산 시 미세한 오차가 발생할 수 있어, 돈과 관련된 계산에는 절대 사용하면 안 됨

     - 예제) 상품 가격과 평점을 저장하는 테이블 생성
```sql
DROP TABLE IF EXISTS product_sample;

CREATE TABLE product_samMARY KEY,
     name VARCHAR(100),
     price DECIMAL(10, 2), -- 99999999.99 까지 저장 가능
     rating DOUBLE -- 평점은 근사치로 저장해도 무방
);

INSERT INTO product_sample (product_id, name, price, rating)
VALUES (1, '프리미엄 키보드', 159000.00, 4.8);
INSERT INTO product_sample (product_id, name, price, rating)
VALUES (2, '고급 마우스', 89500.50, 4.9);
```
   - price에 달러와 같은 소수점을 사용하는 통화라면 DECIMAL을 사용해서 정확도를 보장해야 함
   - rating은 약간의 오차가 있어도 괜찮으므로 DOUBLE을 사용

4. PK 타입 선정 : INT vs BIGINT
   - 기본 키(PK)를 자동 증가(Auto Increment)하는 숫자로 정했다면, 이제 어떤 숫자 타입을 쓸지 결정해야 함
   - 현실적으로 선택지는 INT 와 BIGINT 둘 중 하나로 좁혀짐
      + 과거에는 INT가 PK의 표준처럼 사용되었음 : INT에 UNSIGNED 옵션을 적용하면 0부터 약 42억까지의 숫자를 저장할 수 있음
      + 42억이라는 숫자는 어지간한 서비스에서는 전부 소진하기 어려운 매우 큰 숫자이므로, 대부분의 경우에 충분했음
      + 하지만 현대의 웹 서비스, 특히 쇼핑몰처럼 성공을 목표로 하는 서비스는 데이터 증가 속도를 예측하기 어려움 : 회원이 수천만 명이 되고, 한 회원이 여러 개의 주문을 생성하며, 각 주문마다 여러 개의 주문 상품 데이터가 쌓인다고 가정
      + 핵심적인 데이터인 orders 나 order_item 테이블은 수십억 건을 넘어설 가능성이 충분

   - INT vs BIGINT 성능과 저장 공간 : 그렇다면 왜 고민하는가? 처음부터 가장 큰 BIGINT 를 사용하면 모든 문제가 해결되지 않을까?
     + BIGINT는 INT에 비해 두 배의 저장 공간(8 bytes vs 4 bytes)을 사용
     + 이것이 단순히 디스크 공간만 더 차지하는 문제에서 그치지 않음
     + 데이터베이스에서 성능에 가장 큰 영향을 미치는 것은 I/O(디스크 입출력)
     + 데이터베이스는 인덱스라는 자료구조를 통해 데이터를 빠르게 찾음 : 이때 인덱스 정보도 결국 디스크에 저장되어 있고, 필요할 때 메모리로 읽어와야 함
     + PK는 가장 중요한 인덱스이므로, 데이터 타입의 크기가 작을수록, 한 번에 메모리에 읽어올 수 있는 인덱스 데이터의 양이 많아짐
     + 즉, 더 적은 I/O로 원하는 데이터를 찾을 가능성이 커진다는 의미
     + 따라서 INT를 사용하는 것이 BIGINT를 사용하는 것보다 이론적으로 더 빠르고 효율적

   - BIGINT PK를 사용하는 이유
     + 회원, 상품, 주문, 결제 등 서비스의 핵심 데이터 : 사용자가 계속해서 만들어내는 데이터, 즉 앞으로 얼마나 늘어날지 예측하기 어려운 테이블의 PK는 고민하지 말고 BIGINT를 사용
       * 미래의 위험을 미리 방지하는 것이 현명한 선택
       * 우리 쇼핑몰 예제의 member_id, product_id, order_id가 모두 BIGINT인 이유 (국내 서비스라면 회원의 경우에는 INT를 고려할 수 있음)
     + 카테고리, 상태 코드 등 내부적으로 사용하는 데이터 : 데이터의 최대 개수가 수백, 수천 개 수준으로 명확하게 예측 가능한 테이블(예) 상품 카테고리, 주문 상태 코드 테이블)은 INT를 사용하는 것이 효율적
     + 그럼에도 불구하고, 결론부터 말하면 실무에서는 핵심 테이블의 PK로 BIGINT 사용을 권장
     + INT와 BIGINT의 저장 공간 차이 분석 : BIGINT가 INT 보다 2배의 공간을 사용하는 것은 사실 (하지만 이것이 실제로 얼마나 큰 차이를 만드는지 표로 확인)
<div align="center">
<img src="https://github.com/user-attachments/assets/31d3a30e-fa56-4a85-8c10-9cacb77a5b57">
</div>

   - 쇼핑몰 판매자가 1000명이라면 INT와 BIGINT 차이는 겨우 4 KB 
   - 카테고리가 1만건이라면 INT와 BIGINT 선택의 차이는 겨우 39 KB 차이
   - 상품 데이터가 100만건 이라면 INT와 BIGINT 선택의 용량 차이는 약 3.8 MB에 불과 : 이는 최신 스마트폰의 사진 한 장보다 작은 용량
   - 참고로 데이터베이스 내부의 실제 부가 비용은 더 들 수 있음
   - 1억 건 정도 되어야 약 400MB로 어느정도 의미있는 수준의 차이가 나오기 시작 : 이 정도 차이는 현대의 스토리지 기술 수준에서는 충분히 감당할 수 있는 수준이며, 게다가 데이터가 1억 건에 도달했다는 것 자체가 이미 서비스가 엄청나게 성장했다는 증거이며, INT  사용했다면 이 시점에서는 최대 저장 용량 초과 위험 때문에 BIGINT로의 변경을 심각하게 고려해야 할 것
     + 즉, BIGINT 를 사용함으로써 잃는 저장 공간의 손해는 매우 미미한 반면, 얻게 되는 '규칙의 단순함', '미래 확장성', '관리의 용이성'이라는 이점은 매우 큼

   - 미래 확장성 : INT를 사용해서 얻는 약간의 성능상 이점보다, 나중에 INT의 저장 범위를 초과했을 때 발생하는 재앙적인 비용이 훨씬 더 큼
     + 서비스가 한창 성장하는 와중에 PK 타입을 INT에서 BIGINT로 변경하는 작업(Migration)은 상상 이상으로 고통스러움
     + 서비스 전체를 중단해야 할 수도 있고, 데이터 정합성이 깨질 위험도 큼
   - 실무에서는 또 다른 관점, 바로 '일관성'의 가치를 매우 높게 평가함 : 데이터가 적을 것이라 예상되는 테이블에도 BIGINT를 적용하는 것이 장기적으로 더 나은 선택일 수 있음

   - 일관성이 주는 강력함 : 프로젝트의 모든 테이블 PK를 BIGINT로 통일하면 다음과 같은 장점을 얻을 수 있음
     + 고민의 제거와 개발 생산성 향상 : 개발자는 새로운 테이블을 설계할 때마다 '이 테이블은 데이터가 많이 쌓일까? INT로 충분할까?'를 고민할 필요가 없음
       * 'PK는 BIGINT' 라는 단순하고 명확한 규칙은 개발자의 인지 부하를 줄여주고, 더 중요한 비즈니스 로직에 집중하게 만듬
     + 예측 실패의 위험 방지 : 지금은 데이터가 몇 개 없을 것 같은 '카테고리' 테이블이, 서비스가 고도화되면서 사용자가 직접 카테고리를 생성하고 태그처럼 사용하는 기능으로 확장될 수도 있음
       * 초기의 예측이 틀렸을 때 INT에서 BIGINT로 변경하는 비용은 매우 큼
       * 일관된 BIGINT 정책은 이러한 예측 실패의 위험을 원천적으로 차단하는 '보험'과 같음
     + 외래키 관리의 단순함 : orders 테이블의 member_id는 member 테이블의 member_id를 참조하는 외래키(FK)
       * FK는 참조하는 PK와 반드시 데이터 타입이 같아야 함
       * 만약 어떤 PK는 INT 이고 다른 PK는 BIGINT 라면, FK를 설정할 때마다 참조하는 테이블의 PK 타입을 확인해야 하는 번거로움이 생김
       * 이는 실수로 이어질 가능성을 높임
       * 모든 PK를 BIGINT로 통일하면, 모든 FK 또한 BIGINT로 만들면 되므로 실수를 줄일 수 있음

   - 따라서 많은 최근 실무 현장에서는 성능이나 저장 공간의 미미한 차이보다는, 장기적인 안정성과 유지보수 편의성을 위해 모든 테이블의 PK를 BIGINT로 통일하는 전략을 선호
