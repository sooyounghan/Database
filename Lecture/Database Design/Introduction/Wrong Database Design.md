-----
### 잘못된 설계가 부르는 재앙
-----
1. 데이터베이스 설계란 집을 짓기 전 설계도를 그리는 것과 같음
2. 잘못된 설계가 부르는 재앙
   - 막 시작한 '쇼핑몰'이 있다고 가정 : 개발팀은 빠르게 서비스를 출시하기 위해 데이터베이스 설계에 많은 시간을 들이지 않고, 눈앞의 기능 구현에만 집중
   - 개발팀은 고객과 주문 정보를 관리하기 위해 다음과 같은 orders 테이블 하나를 생성 : 모든 정보를 한곳에 담아두면 관리하기 편할 것이라고 생각
   - orders 테이블 구조
     + order_id : 주문 번호
     + customer_id : 고객 아이디
     + customer_name : 고객 이름
     + customer_address : 고객 주소
     + product_id : 상품 번호
     + product_name : 상품 이름
     + product_price : 상품 가격
     + ordered_at : 주문 날짜

   - 이 테이블에는 다음과 같은 데이터가 쌓이기 시작
<div align="center">
<img src="https://github.com/user-attachments/assets/9397775d-2af1-4179-bf5e-6475ce3b9120">
</div>

3. 나쁜 설계의 3대 문제점 : 나쁜 설계는 크게 세 가지 문제를 일으킴 (데이터 무결성 훼손, 성능 저하, 그리고 유지보수 비용 증가)
   - 데이터 무결성 훼손 (신뢰도 하락)
      + 데이터 무결성이란 데이터가 항상 정확하고 일관된 상태를 유지하는 것을 의미
      + 나쁜 설계는 이 무결성을 아주 쉽게 깨뜨림

   - 데이터 중복
     + '네이트' 고객은 3번 주문 : 그때마다 customer_id, customer_name, customer_address가 반복해서 저장
     + '편한 마우스' 상품 정보도 2번 주문될 때마다 product_id, product_name, product_price가 중복 저장되고 있음
     + 지금은 데이터가 몇 건 없어서 괜찮아 보이지만, 수백만 건의 주문이 쌓일 경우, 엄청난 양의 데이터가 불필요하게 중복되어 저장 공간을 낭비하게 됨
     + 문제는 '이상 현상(Anomaly)'에서 발생


4. 이상 현상(Anomaly) - 수정 이상 (Update Anomaly)
   - 어느 날 '네이트' 고객이 이사를 가서 주소를 '서울시 강남구'에서 '제주시 애월읍'으로 변경해달라고 요청
   - 개발자는 UPDATE 쿼리를 실행해야 함
```sql
UPDATE orders
SET customer_address = '제주시 애월읍'
WHERE customer_id = 'user1';
 ```
   - 이 쿼리를 실행하면 '네이트' 고객의 모든 주문 데이터의 주소가 한 번에 바뀜
   - 지금 구조에서는 WHERE customer_id = 'user1' 조건으로 모든 데이터를 찾아서 변경할 수 있음
   - 하지만 만약 개발자가 실수로 다음과 같이 쿼리를 작성할 경우
 ```sql
UPDATE orders
SET customer_address = '제주시 애월읍'
WHERE order_id = 1005; -- 가장 최근 주문에만 주소를 변경
```
<div align="center">
<img src="https://github.com/user-attachments/assets/06d14680-a69e-4fa1-a0f9-84d2728a6946">
</div>

   - '네이트'라는 동일한 고객의 주소가 주문에 따라 달라짐
   - 즉, 데이터의 일관성이 깨져버림
   - 이는, 이 데이터는 더 이상 신뢰할 수 없는 상태가 됨 (수정 이상)
   - 수정 이상이란, 하나의 정보를 바꾸기 위해 여러 데이터를 수정해야 하고, 그 과정에서 일부가 누락될 때 데이터 불일치가 발생하는 현상

5. 이상 현상(Anomaly) - 삽입 이상 (Insertion Anomaly)
   - '쇼핑몰'이 사업을 확장해서, 아직 주문은 하지 않았지만 마케팅 수신에 동의한 잠재 고객을 미리 등록하고 싶은 상황
   - '션'이라는 신규 고객(user4)을 시스템에 추가
```sql
INSERT INTO orders (customer_id, customer_name, customer_address)
VALUES ('user4', '션', '부산시 해운대구');
```
   - 이 고객은 아직 주문한 적이 없으므로 주문 관련 정보는 없음
   - 만약 이 컬럼들이 NOT NULL 제약조건을 가지고 있다면, 데이터 삽입 자체가 불가능
   - 설령 NULL 을 허용한다고 해도, 주문과 관련 없는 불필요한 NULL 데이터들이 테이블에 쌓이게 됨
   - 즉, 이 테이블 구조에서는 주문을 하지 않으면 고객 정보를 등록할 수 없는 모순이 발생하는데, 이것이 삽입 이상
   - 불필요한 정보(주문 정보)를 함께 넣어야만 원하는 데이터(고객 정보)를 저장할 수 있는 불합리한 상황

6. 이상 현상(Anomaly) - 삭제 이상 (Deletion Anomaly)
   - 시간이 흘러 '이철수' 고객이 탈퇴를 요청
   - 법적인 보관 기간이 지나 그의 유일한 주문 기록(order_id = 1002)을 삭제해야 하는 상황
```sql
DELETE
FROM orders
WHERE customer_id = 'user2';
```
   - 이 쿼리를 실행하면 주문 정보가 깨끗하게 삭제됨과 동시에, '이철수'라는 고객이 우리 쇼핑몰을 이용했다는 고객 정보 자체가 시스템에서 완전히 사라져 버림
   - 나중에 데이터 분석을 위해 '과거에 어떤 고객들이 있었는지'를 알고 싶어도, 그의 주문 내역을 삭제하는 순간 고객 정보까지 함께 소멸되는 것
   - 이처럼 특정 정보를 삭제했을 뿐인데, 유지되어야 할 다른 중요한 정보까지 연쇄적으로 삭제되는 현상을 삭제 이상이라고 함

   - 잘못된 설계는 데이터의 신뢰도를 근본부터 흔들어 놓음

7. 성능 저하 (속도 저하)
   - 서비스가 성장하면서 orders 테이블에는 수억 건의 데이터가 쌓이게 되며, 이제 이 테이블에서 데이터를 조회하는 속도가 눈에 띄게 느려지기 시작
   - 느려지는 조회 속도 : '네이트' 고객의 주문 목록을 조회하는 간단한 쿼리를 생각
```sql
SELECT * 
FROM orders
WHERE customer_id = 'user1';
```
   - 이 쿼리는 매번 거대한 orders 테이블 전체를 뒤져야 함
   - 고객 정보, 상품 정보, 주문 정보가 모두 한 테이블에 섞여있으니 테이블이 '뚱뚱해지고' 길어짐 : 디스크에서 읽어야 할 데이터 양이 많아지니 당연히 속도는 느려짐

8. 유지보수 비용 증가 (확장성 저하)
   - 새로운 요구 사항이 생길 때마다 데이터베이스 구조도 함께 발전해야 하지만, 하지만 잘못된 설계는 이 변화의 발목을 잡음
   - 작은 변경의 큰 파급효과 : 기획팀에서 '고객별 등급(BRONZE, SILVER, GOLD)을 관리하고 싶다'는 새로운 요구 사항을 제시
     + 이 간단한 '등급' 정보를 추가하기 위해, orders 테이블에 customer_grade 라는 컬럼을 추가해야 함
```sql
ALTER TABLE orders
ADD COLUMN customer_grade VARCHAR(10);
```
   - 그리고 '네이트' 고객의 등급을 'GOLD'로 올리려면, 그의 모든 주문 데이터를 일일이 찾아가며 등급을 수정해야 함
```sql
UPDATE orders SET customer_grade = 'GOLD' WHERE customer_id = 'user1';
```
   - 앞서 살펴본 수정 이상 문제가 여기서도 동일하게 발생
   - 더 큰 문제는, 고객과 관련된 아주 작은 정보 하나를 추가했을 뿐인데, 수억 건의 주문 데이터가 담긴 거대한 orders 테이블의 구조를 변경해야 한다는 점
   - 이는 데이터베이스에 엄청난 부하를 주는 위험한 작업이 될 수 있음

   - 애플리케이션 로직의 복잡성 증가 : 위에서 본 '이상 현상'들을 피하기 위해 개발자들은 애플리케이션 레벨에서 방어 로직을 짜기 시작
     + 예를 들어, 고객 주소를 변경할 때는 customer_id로 모든 주문을 찾아서 주소를 업데이트하는 코드를 반드시 넣어야 하고, 신규 고객을 등록할 때는 주문 정보 없이 고객 정보만 임시 테이블에 넣었다가 첫 주문 시 orders 테이블로 옮기는 등의 복잡한 로직을 추가하게 됨
     + 데이터베이스가 제 역할을 못하니, 그 부담이 고스란히 애플리케이션 코드로 전가되어 시스템 전체가 비대하고 복잡해지는 결과를 낳음
  
   - 극단적인 예시지만 이것이 바로 '나쁜 설계'가 불러오는 문제들 : 데이터는 뒤죽박죽이 되고, 시스템은 느려지며, 작은 변화에도 전체가 휘청거리게 됨
